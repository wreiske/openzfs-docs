

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>zfs-module-parameters.5 &mdash; OpenZFS  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme_overrides.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/mandoc.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="zpool-features.5" href="zpool-features.5.html" />
    <link rel="prev" title="zfs-events.5" href="zfs-events.5.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #29667e" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo_main.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Getting Started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Project and Community/index.html">Project and Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Developer Resources/index.html">Developer Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Performance and Tuning/index.html">Performance and Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Basic Concepts/index.html">Basic Concepts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Man Pages</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../1/index.html">User Commands (1)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">File Formats and Conventions (5)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="spl-module-parameters.5.html">spl-module-parameters.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="vdev_id.conf.5.html">vdev_id.conf.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="zfs-events.5.html">zfs-events.5</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">zfs-module-parameters.5</a></li>
<li class="toctree-l3"><a class="reference internal" href="zpool-features.5.html">zpool-features.5</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../8/index.html">System Administration Commands (8)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../msg/index.html">ZFS Messages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../License.html">License</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OpenZFS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Man Pages</a> &raquo;</li>
        
          <li><a href="index.html">File Formats and Conventions (5)</a> &raquo;</li>
        
      <li>zfs-module-parameters.5</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/openzfs/openzfs-docs/blob/master/docs/man/5/zfs-module-parameters.5.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="zfs-module-parameters-5">
<h1>zfs-module-parameters.5<a class="headerlink" href="#zfs-module-parameters-5" title="Permalink to this headline">Â¶</a></h1>
<div class="man_container"><table class="head">
  <tr>
    <td class="head-ltitle">ZFS-MODULE-PARAMETERS(5)</td>
    <td class="head-vol">File Formats Manual</td>
    <td class="head-rtitle">ZFS-MODULE-PARAMETERS(5)</td>
  </tr>
</table>
<div class="manual-text">
<h1 class="Sh" title="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
zfs-module-parameters - ZFS module parameters
<h1 class="Sh" title="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Description of the different parameters to the ZFS module.
<div class="Pp"></div>
<h2 class="Ss" title="Ss" id="Module_parameters"><a class="permalink" href="#Module_parameters">Module
  parameters</a></h2>
<b>dbuf_cache_max_bytes</b> (ulong)
<div class="Bd-indent">Maximum size in bytes of the dbuf cache. The target size
  is determined by the MIN versus <b>1/2^dbuf_cache_shift</b> (1/32) of the
  target ARC size. The behavior of the dbuf cache and its associated settings
  can be observed via the <b>/proc/spl/kstat/zfs/dbufstats</b> kstat.
<div class="Pp"></div>
Default value: <b>ULONG_MAX</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dbuf_metadata_cache_max_bytes</b> (ulong)
<div class="Bd-indent">Maximum size in bytes of the metadata dbuf cache. The
  target size is determined by the MIN versus
  <b>1/2^dbuf_metadata_cache_shift</b> (1/64) of the target ARC size. The
  behavior of the metadata dbuf cache and its associated settings can be
  observed via the <b>/proc/spl/kstat/zfs/dbufstats</b> kstat.
<div class="Pp"></div>
Default value: <b>ULONG_MAX</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dbuf_cache_hiwater_pct</b> (uint)
<div class="Bd-indent">The percentage over <b>dbuf_cache_max_bytes</b> when
  dbufs must be evicted directly.
<div class="Pp"></div>
Default value: <b>10</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dbuf_cache_lowater_pct</b> (uint)
<div class="Bd-indent">The percentage below <b>dbuf_cache_max_bytes</b> when the
  evict thread stops evicting dbufs.
<div class="Pp"></div>
Default value: <b>10</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dbuf_cache_shift</b> (int)
<div class="Bd-indent">Set the size of the dbuf cache,
  <b>dbuf_cache_max_bytes</b>, to a log2 fraction of the target ARC size.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dbuf_metadata_cache_shift</b> (int)
<div class="Bd-indent">Set the size of the dbuf metadata cache,
  <b>dbuf_metadata_cache_max_bytes</b>, to a log2 fraction of the target ARC
  size.
<div class="Pp"></div>
Default value: <b>6</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dmu_object_alloc_chunk_shift</b> (int)
<div class="Bd-indent">dnode slots allocated in a single operation as a power of
  2. The default value minimizes lock contention for the bulk operation
  performed.
<div class="Pp"></div>
Default value: <b>7</b> (128).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>dmu_prefetch_max</b> (int)
<div class="Bd-indent">Limit the amount we can prefetch with one call to this
  amount (in bytes). This helps to limit the amount of memory that can be used
  by prefetching.
<div class="Pp"></div>
Default value: <b>134,217,728</b> (128MB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>ignore_hole_birth</b> (int)
<div class="Bd-indent">This is an alias for
  <b>send_holes_without_birth_time</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_feed_again</b> (int)
<div class="Bd-indent">Turbo L2ARC warm-up. When the L2ARC is cold the fill
  interval will be set as fast as possible.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> to disable.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_feed_min_ms</b> (ulong)
<div class="Bd-indent">Min feed interval in milliseconds. Requires
  <b>l2arc_feed_again=1</b> and only applicable in related situations.
<div class="Pp"></div>
Default value: <b>200</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_feed_secs</b> (ulong)
<div class="Bd-indent">Seconds between L2ARC writing
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_headroom</b> (ulong)
<div class="Bd-indent">How far through the ARC lists to search for L2ARC
  cacheable content, expressed as a multiplier of <b>l2arc_write_max</b>. ARC
  persistence across reboots can be achieved with persistent L2ARC by setting
  this parameter to <b>0</b> allowing the full length of ARC lists to be
  searched for cacheable content.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_headroom_boost</b> (ulong)
<div class="Bd-indent">Scales <b>l2arc_headroom</b> by this percentage when
  L2ARC contents are being successfully compressed before writing. A value of
  <b>100</b> disables this feature.
<div class="Pp"></div>
Default value: <b>200</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_mfuonly</b> (int)
<div class="Bd-indent">Controls whether only MFU metadata and data are cached
  from ARC into L2ARC. This may be desired to avoid wasting space on L2ARC when
  reading/writing large amounts of data that are not expected to be accessed
  more than once. The default is <b>0</b>, meaning both MRU and MFU data and
  metadata are cached. When turning off ( <b>0</b>) this feature some MRU
  buffers will still be present in ARC and eventually cached on L2ARC. If
  <b>l2arc_noprefetch</b> is set to 0, some prefetched buffers will be cached to
  L2ARC, and those might later transition to MRU, in which case the
  <b>l2arc_mru_asize</b> arcstat will not be 0. Regardless of
  <b>l2arc_noprefetch</b>, some MFU buffers might be evicted from ARC, accessed
  later on as prefetches and transition to MRU as prefetches. If accessed again
  they are counted as MRU and the <b>l2arc_mru_asize</b> arcstat will not be 0.
  The ARC status of L2ARC buffers when they were first cached in L2ARC can be
  seen in the <b>l2arc_mru_asize</b>, <b>l2arc_mfu_asize</b> and
  <b>l2arc_prefetch_asize</b> arcstats when importing the pool or onlining a
  cache device if persistent L2ARC is enabled. The
  <b>evicted_l2_eligible_mru</b> arcstat does not take into account if this
  option is enabled as the information provided by the evicted_l2_eligible_*
  arcstats can be used to decide if toggling this option is appropriate for the
  current workload.
<div class="Pp"></div>
Use <b>0</b> for no (default) and <b>1</b> for yes.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_meta_percent</b> (int)
<div class="Bd-indent">Percent of ARC size allowed for L2ARC-only headers. Since
  L2ARC buffers are not evicted on memory pressure, too large amount of headers
  on system with irrationally large L2ARC can render it slow or unusable. This
  parameter limits L2ARC writes and rebuild to achieve it.
<div class="Pp"></div>
Default value: <b>33</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_trim_ahead</b> (ulong)
<div class="Bd-indent">Trims ahead of the current write size
  (<b>l2arc_write_max</b>) on L2ARC devices by this percentage of write size if
  we have filled the device. If set to <b>100</b> we TRIM twice the space
  required to accommodate upcoming writes. A minimum of 64MB will be trimmed. It
  also enables TRIM of the whole L2ARC device upon creation or addition to an
  existing pool or if the header of the device is invalid upon importing a pool
  or onlining a cache device. A value of <b>0</b> disables TRIM on L2ARC
  altogether and is the default as it can put significant stress on the
  underlying storage devices. This will vary depending of how well the specific
  device handles these commands.
<div class="Pp"></div>
Default value: <b>0</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_noprefetch</b> (int)
<div class="Bd-indent">Do not write buffers to L2ARC if they were prefetched but
  not used by applications. In case there are prefetched buffers in L2ARC and
  this option is later set to <b>1</b>, we do not read the prefetched buffers
  from L2ARC. Setting this option to <b>0</b> is useful for caching sequential
  reads from the disks to L2ARC and serve those reads from L2ARC later on. This
  may be beneficial in case the L2ARC device is significantly faster in
  sequential reads than the disks of the pool.
<div class="Pp"></div>
Use <b>1</b> to disable (default) and <b>0</b> to enable caching/reading
  prefetches to/from L2ARC..</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_norw</b> (int)
<div class="Bd-indent">No reads during writes.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_write_boost</b> (ulong)
<div class="Bd-indent">Cold L2ARC devices will have <b>l2arc_write_max</b>
  increased by this amount while they remain cold.
<div class="Pp"></div>
Default value: <b>8,388,608</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_write_max</b> (ulong)
<div class="Bd-indent">Max write bytes per interval.
<div class="Pp"></div>
Default value: <b>8,388,608</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_rebuild_enabled</b> (int)
<div class="Bd-indent">Rebuild the L2ARC when importing a pool (persistent
  L2ARC). This can be disabled if there are problems importing a pool or
  attaching an L2ARC device (e.g. the L2ARC device is slow in reading stored log
  metadata, or the metadata has become somehow fragmented/unusable).
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>l2arc_rebuild_blocks_min_l2size</b> (ulong)
<div class="Bd-indent">Min size (in bytes) of an L2ARC device required in order
  to write log blocks in it. The log blocks are used upon importing the pool to
  rebuild the L2ARC (persistent L2ARC). Rationale: for L2ARC devices less than
  1GB, the amount of data l2arc_evict() evicts is significant compared to the
  amount of restored L2ARC data. In this case do not write log blocks in L2ARC
  in order not to waste space.
<div class="Pp"></div>
Default value: <b>1,073,741,824</b> (1GB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_aliquot</b> (ulong)
<div class="Bd-indent">Metaslab granularity, in bytes. This is roughly similar
  to what would be referred to as the &quot;stripe size&quot; in traditional
  RAID arrays. In normal operation, ZFS will try to write this amount of data to
  a top-level vdev before moving on to the next one.
<div class="Pp"></div>
Default value: <b>524,288</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_bias_enabled</b> (int)
<div class="Bd-indent">Enable metaslab group biasing based on its vdev's over-
  or under-utilization relative to the pool.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_force_ganging</b> (ulong)
<div class="Bd-indent">Make some blocks above a certain size be gang blocks.
  This option is used by the test suite to facilitate testing.
<div class="Pp"></div>
Default value: <b>16,777,217</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_history_output_max</b> (int)
<div class="Bd-indent">When attempting to log the output nvlist of an ioctl in
  the on-disk history, the output will not be stored if it is larger than size
  (in bytes). This must be less than DMU_MAX_ACCESS (64MB). This applies
  primarily to zfs_ioc_channel_program().
<div class="Pp"></div>
Default value: <b>1MB</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_keep_log_spacemaps_at_export</b> (int)
<div class="Bd-indent">Prevent log spacemaps from being destroyed during pool
  exports and destroys.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_segment_weight_enabled</b> (int)
<div class="Bd-indent">Enable/disable segment-based metaslab selection.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_switch_threshold</b> (int)
<div class="Bd-indent">When using segment-based metaslab selection, continue
  allocating from the active metaslab until <b>zfs_metaslab_switch_threshold</b>
  worth of buckets have been exhausted.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_debug_load</b> (int)
<div class="Bd-indent">Load all metaslabs during pool import.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_debug_unload</b> (int)
<div class="Bd-indent">Prevent metaslabs from being unloaded.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_fragmentation_factor_enabled</b> (int)
<div class="Bd-indent">Enable use of the fragmentation metric in computing
  metaslab weights.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_df_max_search</b> (int)
<div class="Bd-indent">Maximum distance to search forward from the last offset.
  Without this limit, fragmented pools can see &gt;100,000 iterations and
  metaslab_block_picker() becomes the performance limiting factor on
  high-performance storage.
<div class="Pp"></div>
With the default setting of 16MB, we typically see less than 500 iterations,
  even with very fragmented, ashift=9 pools. The maximum number of iterations
  possible is: <b>metaslab_df_max_search / (2 * (1&lt;&lt;ashift))</b>. With the
  default setting of 16MB this is 16*1024 (with ashift=9) or 2048 (with
  ashift=12).
<div class="Pp"></div>
Default value: <b>16,777,216</b> (16MB)</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_df_use_largest_segment</b> (int)
<div class="Bd-indent">If we are not searching forward (due to
  metaslab_df_max_search, metaslab_df_free_pct, or metaslab_df_alloc_threshold),
  this tunable controls what segment is used. If it is set, we will use the
  largest free segment. If it is not set, we will use a segment of exactly the
  requested size (or larger).
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_max_size_cache_sec</b> (ulong)
<div class="Bd-indent">When we unload a metaslab, we cache the size of the
  largest free chunk. We use that cached size to determine whether or not to
  load a metaslab for a given allocation. As more frees accumulate in that
  metaslab while it's unloaded, the cached max size becomes less and less
  accurate. After a number of seconds controlled by this tunable, we stop
  considering the cached max size and start considering only the histogram
  instead.
<div class="Pp"></div>
Default value: <b>3600 seconds</b> (one hour)</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_mem_limit</b> (int)
<div class="Bd-indent">When we are loading a new metaslab, we check the amount
  of memory being used to store metaslab range trees. If it is over a threshold,
  we attempt to unload the least recently used metaslab to prevent the system
  from clogging all of its memory with range trees. This tunable sets the
  percentage of total system memory that is the threshold.
<div class="Pp"></div>
Default value: <b>25 percent</b></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_try_hard_before_gang</b> (int)
<div class="Bd-indent">If not set (the default), we will first try normal
  allocation. If that fails then we will do a gang allocation. If that fails
  then we will do a &quot;try hard&quot; gang allocation. If that fails then we
  will have a multi-layer gang block.
<div class="Pp"></div>
If set, we will first try normal allocation. If that fails then we will do a
  &quot;try hard&quot; allocation. If that fails we will do a gang allocation.
  If that fails we will do a &quot;try hard&quot; gang allocation. If that fails
  then we will have a multi-layer gang block.
<div class="Pp"></div>
Default value: <b>0 (false)</b></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_find_max_tries</b> (int)
<div class="Bd-indent">When not trying hard, we only consider this number of the
  best metaslabs. This improves performance, especially when there are many
  metaslabs per vdev and the allocation can't actually be satisfied (so we would
  otherwise iterate all the metaslabs).
<div class="Pp"></div>
Default value: <b>100</b></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_default_ms_count</b> (int)
<div class="Bd-indent">When a vdev is added target this number of metaslabs per
  top-level vdev.
<div class="Pp"></div>
Default value: <b>200</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_default_ms_shift</b> (int)
<div class="Bd-indent">Default limit for metaslab size.
<div class="Pp"></div>
Default value: <b>29</b> [meaning (1 &lt;&lt; 29) = 512MB].</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_max_auto_ashift</b> (ulong)
<div class="Bd-indent">Maximum ashift used when optimizing for logical -&gt;
  physical sector size on new top-level vdevs.
<div class="Pp"></div>
Default value: <b>ASHIFT_MAX</b> (16).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_min_auto_ashift</b> (ulong)
<div class="Bd-indent">Minimum ashift used when creating new top-level vdevs.
<div class="Pp"></div>
Default value: <b>ASHIFT_MIN</b> (9).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_min_ms_count</b> (int)
<div class="Bd-indent">Minimum number of metaslabs to create in a top-level
  vdev.
<div class="Pp"></div>
Default value: <b>16</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>vdev_validate_skip</b> (int)
<div class="Bd-indent">Skip label validation steps during pool import. Changing
  is not recommended unless you know what you are doing and are recovering a
  damaged label.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_ms_count_limit</b> (int)
<div class="Bd-indent">Practical upper limit of total metaslabs per top-level
  vdev.
<div class="Pp"></div>
Default value: <b>131,072</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_preload_enabled</b> (int)
<div class="Bd-indent">Enable metaslab group preloading.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_lba_weighting_enabled</b> (int)
<div class="Bd-indent">Give more weight to metaslabs with lower LBAs, assuming
  they have greater bandwidth as is typically the case on a modern constant
  angular velocity disk drive.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_unload_delay</b> (int)
<div class="Bd-indent">After a metaslab is used, we keep it loaded for this many
  txgs, to attempt to reduce unnecessary reloading. Note that both this many
  txgs and <b>metaslab_unload_delay_ms</b> milliseconds must pass before
  unloading will occur.
<div class="Pp"></div>
Default value: <b>32</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>metaslab_unload_delay_ms</b> (int)
<div class="Bd-indent">After a metaslab is used, we keep it loaded for this many
  milliseconds, to attempt to reduce unnecessary reloading. Note that both this
  many milliseconds and <b>metaslab_unload_delay</b> txgs must pass before
  unloading will occur.
<div class="Pp"></div>
Default value: <b>600000</b> (ten minutes).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>reference_history</b> (int)
<div class="Bd-indent">Maximum reference holders being tracked when
  reference_tracking_enable is active.
<div class="Pp"></div>
Default value: <b>3</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>reference_tracking_enable</b> (int)
<div class="Bd-indent">Track reference holders to refcount_t objects (debug
  builds only).
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>send_holes_without_birth_time</b> (int)
<div class="Bd-indent">When set, the hole_birth optimization will not be used,
  and all holes will always be sent on zfs send. This is useful if you suspect
  your datasets are affected by a bug in hole_birth.
<div class="Pp"></div>
Use <b>1</b> for on (default) and <b>0</b> for off.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_config_path</b> (charp)
<div class="Bd-indent">SPA config file
<div class="Pp"></div>
Default value: <b>/etc/zfs/zpool.cache</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_asize_inflation</b> (int)
<div class="Bd-indent">Multiplication factor used to estimate actual disk
  consumption from the size of data being written. The default value is a worst
  case estimate, but lower values may be valid for a given pool depending on its
  configuration. Pool administrators who understand the factors involved may
  wish to specify a more realistic inflation factor, particularly if they
  operate close to quota or capacity limits.
<div class="Pp"></div>
Default value: <b>24</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_load_print_vdev_tree</b> (int)
<div class="Bd-indent">Whether to print the vdev tree in the debugging message
  buffer during pool import. Use 0 to disable and 1 to enable.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_load_verify_data</b> (int)
<div class="Bd-indent">Whether to traverse data blocks during an &quot;extreme
  rewind&quot; ( <b>-X</b>) import. Use 0 to disable and 1 to enable.
<div class="Pp"></div>
An extreme rewind import normally performs a full traversal of all blocks in the
  pool for verification. If this parameter is set to 0, the traversal skips
  non-metadata blocks. It can be toggled once the import has started to stop or
  start the traversal of non-metadata blocks.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_load_verify_metadata</b> (int)
<div class="Bd-indent">Whether to traverse blocks during an &quot;extreme
  rewind&quot; ( <b>-X</b>) pool import. Use 0 to disable and 1 to enable.
<div class="Pp"></div>
An extreme rewind import normally performs a full traversal of all blocks in the
  pool for verification. If this parameter is set to 0, the traversal is not
  performed. It can be toggled once the import has started to stop or start the
  traversal.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_load_verify_shift</b> (int)
<div class="Bd-indent">Sets the maximum number of bytes to consume during pool
  import to the log2 fraction of the target ARC size.
<div class="Pp"></div>
Default value: <b>4</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>spa_slop_shift</b> (int)
<div class="Bd-indent">Normally, we don't allow the last 3.2%
  (1/(2^spa_slop_shift)) of space in the pool to be consumed. This ensures that
  we don't run the pool completely out of space, due to unaccounted changes
  (e.g. to the MOS). It also limits the worst-case time to allocate space. If we
  have less than this amount of free space, most ZPL operations (e.g. write,
  create) will return ENOSPC.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>vdev_removal_max_span</b> (int)
<div class="Bd-indent">During top-level vdev removal, chunks of data are copied
  from the vdev which may include free space in order to trade bandwidth for
  IOPS. This parameter determines the maximum span of free space (in bytes)
  which will be included as &quot;unnecessary&quot; data in a chunk of copied
  data.
<div class="Pp"></div>
The default value here was chosen to align with <b>zfs_vdev_read_gap_limit</b>,
  which is a similar concept when doing regular reads (but there's no reason it
  has to be the same).
<div class="Pp"></div>
Default value: <b>32,768</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>vdev_file_logical_ashift</b> (ulong)
<div class="Bd-indent">Logical ashift for file-based devices.
<div class="Pp"></div>
Default value: <b>9</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>vdev_file_physical_ashift</b> (ulong)
<div class="Bd-indent">Physical ashift for file-based devices.
<div class="Pp"></div>
Default value: <b>9</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zap_iterate_prefetch</b> (int)
<div class="Bd-indent">If this is set, when we start iterating over a ZAP
  object, zfs will prefetch the entire object (all leaf blocks). However, this
  is limited by <b>dmu_prefetch_max</b>.
<div class="Pp"></div>
Use <b>1</b> for on (default) and <b>0</b> for off.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfetch_array_rd_sz</b> (ulong)
<div class="Bd-indent">If prefetching is enabled, disable prefetching for reads
  larger than this size.
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfetch_max_distance</b> (uint)
<div class="Bd-indent">Max bytes to prefetch per stream.
<div class="Pp"></div>
Default value: <b>8,388,608</b> (8MB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfetch_max_idistance</b> (uint)
<div class="Bd-indent">Max bytes to prefetch indirects for per stream.
<div class="Pp"></div>
Default value: <b>67,108,864</b> (64MB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfetch_max_streams</b> (uint)
<div class="Bd-indent">Max number of streams per zfetch (prefetch streams per
  file).
<div class="Pp"></div>
Default value: <b>8</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfetch_min_sec_reap</b> (uint)
<div class="Bd-indent">Min time before an active prefetch stream can be
  reclaimed
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_abd_scatter_enabled</b> (int)
<div class="Bd-indent">Enables ARC from using scatter/gather lists and forces
  all allocations to be linear in kernel memory. Disabling can improve
  performance in some code paths at the expense of fragmented kernel memory.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_abd_scatter_max_order</b> (iunt)
<div class="Bd-indent">Maximum number of consecutive memory pages allocated in a
  single block for scatter/gather lists. Default value is specified by the
  kernel itself.
<div class="Pp"></div>
Default value: <b>10</b> at the time of this writing.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_abd_scatter_min_size</b> (uint)
<div class="Bd-indent">This is the minimum allocation size that will use scatter
  (page-based) ABD's. Smaller allocations will use linear ABD's.
<div class="Pp"></div>
Default value: <b>1536</b> (512B and 1KB allocations will be linear).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_dnode_limit</b> (ulong)
<div class="Bd-indent">When the number of bytes consumed by dnodes in the ARC
  exceeds this number of bytes, try to unpin some of it in response to demand
  for non-metadata. This value acts as a ceiling to the amount of dnode
  metadata, and defaults to 0 which indicates that a percent which is based on
  <b>zfs_arc_dnode_limit_percent</b> of the ARC meta buffers that may be used
  for dnodes.
<div class="Pp"></div>
See also <b>zfs_arc_meta_prune</b> which serves a similar purpose but is used
  when the amount of metadata in the ARC exceeds <b>zfs_arc_meta_limit</b>
  rather than in response to overall demand for non-metadata.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_dnode_limit_percent</b> (ulong)
<div class="Bd-indent">Percentage that can be consumed by dnodes of ARC meta
  buffers.
<div class="Pp"></div>
See also <b>zfs_arc_dnode_limit</b> which serves a similar purpose but has a
  higher priority if set to nonzero value.
<div class="Pp"></div>
Default value: <b>10</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_dnode_reduce_percent</b> (ulong)
<div class="Bd-indent">Percentage of ARC dnodes to try to scan in response to
  demand for non-metadata when the number of bytes consumed by dnodes exceeds
  <b>zfs_arc_dnode_limit</b>.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>10</b>% of the number of dnodes in the ARC.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_average_blocksize</b> (int)
<div class="Bd-indent">The ARC's buffer hash table is sized based on the
  assumption of an average block size of <b>zfs_arc_average_blocksize</b>
  (default 8K). This works out to roughly 1MB of hash table per 1GB of physical
  memory with 8-byte pointers. For configurations with a known larger average
  block size this value can be increased to reduce the memory footprint.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>8192</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_eviction_pct</b> (int)
<div class="Bd-indent">When <b>arc_is_overflowing()</b>,
  <b>arc_get_data_impl()</b> waits for this percent of the requested amount of
  data to be evicted. For example, by default for every 2KB that's evicted, 1KB
  of it may be &quot;reused&quot; by a new allocation. Since this is above 100%,
  it ensures that progress is made towards getting <b>arc_size</b> under
  <b>arc_c</b>. Since this is finite, it ensures that allocations can still
  happen, even during the potentially long time that <b>arc_size</b> is more
  than <b>arc_c</b>.
<div class="Pp"></div>
Default value: <b>200</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_evict_batch_limit</b> (int)
<div class="Bd-indent">Number ARC headers to evict per sub-list before
  proceeding to another sub-list. This batch-style operation prevents entire
  sub-lists from being evicted at once but comes at a cost of additional
  unlocking and locking.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_grow_retry</b> (int)
<div class="Bd-indent">If set to a non zero value, it will replace the
  arc_grow_retry value with this value. The arc_grow_retry value (default 5) is
  the number of seconds the ARC will wait before trying to resume growth after a
  memory pressure event.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_lotsfree_percent</b> (int)
<div class="Bd-indent">Throttle I/O when free system memory drops below this
  percentage of total system memory. Setting this value to 0 will disable the
  throttle.
<div class="Pp"></div>
Default value: <b>10</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_max</b> (ulong)
<div class="Bd-indent">Max size of ARC in bytes. If set to 0 then the max size
  of ARC is determined by the amount of system memory installed. For Linux, 1/2
  of system memory will be used as the limit. For FreeBSD, the larger of all
  system memory - 1GB or 5/8 of system memory will be used as the limit. This
  value must be at least 67108864 (64 megabytes).
<div class="Pp"></div>
This value can be changed dynamically with some caveats. It cannot be set back
  to 0 while running and reducing it below the current ARC size will not cause
  the ARC to shrink without memory pressure to induce shrinking.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_adjust_restarts</b> (ulong)
<div class="Bd-indent">The number of restart passes to make while scanning the
  ARC attempting the free buffers in order to stay below the
  <b>zfs_arc_meta_limit</b>. This value should not need to be tuned but is
  available to facilitate performance analysis.
<div class="Pp"></div>
Default value: <b>4096</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_limit</b> (ulong)
<div class="Bd-indent">The maximum allowed size in bytes that meta data buffers
  are allowed to consume in the ARC. When this limit is reached meta data
  buffers will be reclaimed even if the overall arc_c_max has not been reached.
  This value defaults to 0 which indicates that a percent which is based on
  <b>zfs_arc_meta_limit_percent</b> of the ARC may be used for meta data.
<div class="Pp"></div>
This value my be changed dynamically except that it cannot be set back to 0 for
  a specific percent of the ARC; it must be set to an explicit value.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_limit_percent</b> (ulong)
<div class="Bd-indent">Percentage of ARC buffers that can be used for meta data.
<div class="Pp"></div>
See also <b>zfs_arc_meta_limit</b> which serves a similar purpose but has a
  higher priority if set to nonzero value.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>75</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_min</b> (ulong)
<div class="Bd-indent">The minimum allowed size in bytes that meta data buffers
  may consume in the ARC. This value defaults to 0 which disables a floor on the
  amount of the ARC devoted meta data.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_prune</b> (int)
<div class="Bd-indent">The number of dentries and inodes to be scanned looking
  for entries which can be dropped. This may be required when the ARC reaches
  the <b>zfs_arc_meta_limit</b> because dentries and inodes can pin buffers in
  the ARC. Increasing this value will cause to dentry and inode caches to be
  pruned more aggressively. Setting this value to 0 will disable pruning the
  inode and dentry caches.
<div class="Pp"></div>
Default value: <b>10,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_meta_strategy</b> (int)
<div class="Bd-indent">Define the strategy for ARC meta data buffer eviction
  (meta reclaim strategy). A value of 0 (META_ONLY) will evict only the ARC meta
  data buffers. A value of 1 (BALANCED) indicates that additional data buffers
  may be evicted if that is required to in order to evict the required number of
  meta data buffers.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_min</b> (ulong)
<div class="Bd-indent">Min size of ARC in bytes. If set to 0 then arc_c_min will
  default to consuming the larger of 32M or 1/32 of total system memory.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_min_prefetch_ms</b> (int)
<div class="Bd-indent">Minimum time prefetched blocks are locked in the ARC,
  specified in ms. A value of <b>0</b> will default to 1000 ms.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_min_prescient_prefetch_ms</b> (int)
<div class="Bd-indent">Minimum time &quot;prescient prefetched&quot; blocks are
  locked in the ARC, specified in ms. These blocks are meant to be prefetched
  fairly aggressively ahead of the code that may use them. A value of <b>0</b>
  will default to 6000 ms.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_missing_tvds</b> (int)
<div class="Bd-indent">Number of missing top-level vdevs which will be allowed
  during pool import (only in read-only mode).
<div class="Pp"></div>
Default value: <b>0</b></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_nvlist_src_size</b> (ulong)
<div class="Bd-indent">Maximum size in bytes allowed to be passed as
  zc_nvlist_src_size for ioctls on /dev/zfs. This prevents a user from causing
  the kernel to allocate an excessive amount of memory. When the limit is
  exceeded, the ioctl fails with EINVAL and a description of the error is sent
  to the zfs-dbgmsg log. This parameter should not need to be touched under
  normal circumstances. On FreeBSD, the default is based on the system limit on
  user wired memory. On Linux, the default is <b>128MB</b>.
<div class="Pp"></div>
Default value: <b>0</b> (kernel decides)</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_multilist_num_sublists</b> (int)
<div class="Bd-indent">To allow more fine-grained locking, each ARC state
  contains a series of lists for both data and meta data objects. Locking is
  performed at the level of these &quot;sub-lists&quot;. This parameters
  controls the number of sub-lists per ARC state, and also applies to other uses
  of the multilist data structure.
<div class="Pp"></div>
Default value: <b>4</b> or the number of online CPUs, whichever is greater</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_overflow_shift</b> (int)
<div class="Bd-indent">The ARC size is considered to be overflowing if it
  exceeds the current ARC target size (arc_c) by a threshold determined by this
  parameter. The threshold is calculated as a fraction of arc_c using the
  formula &quot;arc_c &gt;&gt; <b>zfs_arc_overflow_shift</b>&quot;.
<div class="Pp"></div>
The default value of 8 causes the ARC to be considered to be overflowing if it
  exceeds the target size by 1/256th (0.3%) of the target size.
<div class="Pp"></div>
When the ARC is overflowing, new buffer allocations are stalled until the
  reclaim thread catches up and the overflow condition no longer exists.
<div class="Pp"></div>
Default value: <b>8</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_p_min_shift</b> (int)
<div class="Bd-indent">If set to a non zero value, this will update
  arc_p_min_shift (default 4) with the new value. arc_p_min_shift is used to
  shift of arc_c for calculating both min and max max arc_p
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_p_dampener_disable</b> (int)
<div class="Bd-indent">Disable arc_p adapt dampener
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> to disable.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_shrink_shift</b> (int)
<div class="Bd-indent">If set to a non zero value, this will update
  arc_shrink_shift (default 7) with the new value.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_pc_percent</b> (uint)
<div class="Bd-indent">Percent of pagecache to reclaim arc to
<div class="Pp"></div>
This tunable allows ZFS arc to play more nicely with the kernel's LRU pagecache.
  It can guarantee that the ARC size won't collapse under scanning pressure on
  the pagecache, yet still allows arc to be reclaimed down to zfs_arc_min if
  necessary. This value is specified as percent of pagecache size (as measured
  by NR_FILE_PAGES) where that percent may exceed 100. This only operates during
  memory pressure/reclaim.
<div class="Pp"></div>
Default value: <b>0</b>% (disabled).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_shrinker_limit</b> (int)
<div class="Bd-indent">This is a limit on how many pages the ARC shrinker makes
  available for eviction in response to one page allocation attempt. Note that
  in practice, the kernel's shrinker can ask us to evict up to about 4x this for
  one allocation attempt.
<div class="Pp"></div>
The default limit of 10,000 (in practice, 160MB per allocation attempt with 4K
  pages) limits the amount of time spent attempting to reclaim ARC memory to
  less than 100ms per allocation attempt, even with a small average compressed
  block size of ~8KB.
<div class="Pp"></div>
The parameter can be set to 0 (zero) to disable the limit.
<div class="Pp"></div>
This parameter only applies on Linux.
<div class="Pp"></div>
Default value: <b>10,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_arc_sys_free</b> (ulong)
<div class="Bd-indent">The target number of bytes the ARC should leave as free
  memory on the system. Defaults to the larger of 1/64 of physical memory or
  512K. Setting this option to a non-zero value will override the default.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_autoimport_disable</b> (int)
<div class="Bd-indent">Disable pool import at module load by ignoring the cache
  file (typically <b>/etc/zfs/zpool.cache</b>).
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_checksum_events_per_second</b> (uint)
<div class="Bd-indent">Rate limit checksum events to this many per second. Note
  that this should not be set below the zed thresholds (currently 10 checksums
  over 10 sec) or else zed may not trigger any action.
<div class="Pp"></div>
Default value: 20</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_commit_timeout_pct</b> (int)
<div class="Bd-indent">This controls the amount of time that a ZIL block (lwb)
  will remain &quot;open&quot; when it isn't &quot;full&quot;, and it has a
  thread waiting for it to be committed to stable storage. The timeout is scaled
  based on a percentage of the last lwb latency to avoid significantly impacting
  the latency of each individual transaction record (itx).
<div class="Pp"></div>
Default value: <b>5</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_condense_indirect_commit_entry_delay_ms</b> (int)
<div class="Bd-indent">Vdev indirection layer (used for device removal) sleeps
  for this many milliseconds during mapping generation. Intended for use with
  the test suite to throttle vdev removal speed.
<div class="Pp"></div>
Default value: <b>0</b> (no throttle).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_condense_indirect_obsolete_pct</b> (int)
<div class="Bd-indent">Minimum percent of obsolete bytes in vdev mapping
  required to attempt to condense (see
  <b>zfs_condense_indirect_vdevs_enable</b>). Intended for use with the test
  suite to facilitate triggering condensing as needed.
<div class="Pp"></div>
Default value: <b>25</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_condense_indirect_vdevs_enable</b> (int)
<div class="Bd-indent">Enable condensing indirect vdev mappings. When set to a
  non-zero value, attempt to condense indirect vdev mappings if the mapping uses
  more than <b>zfs_condense_min_mapping_bytes</b> bytes of memory and if the
  obsolete space map object uses more than
  <b>zfs_condense_max_obsolete_bytes</b> bytes on-disk. The condensing process
  is an attempt to save memory by removing obsolete mappings.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_condense_max_obsolete_bytes</b> (ulong)
<div class="Bd-indent">Only attempt to condense indirect vdev mappings if the
  on-disk size of the obsolete space map object is greater than this number of
  bytes (see <b>fBzfs_condense_indirect_vdevs_enable</b>).
<div class="Pp"></div>
Default value: <b>1,073,741,824</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_condense_min_mapping_bytes</b> (ulong)
<div class="Bd-indent">Minimum size vdev mapping to attempt to condense (see
  <b>zfs_condense_indirect_vdevs_enable</b>).
<div class="Pp"></div>
Default value: <b>131,072</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dbgmsg_enable</b> (int)
<div class="Bd-indent">Internally ZFS keeps a small log to facilitate debugging.
  By default the log is enabled, to disable it set this option to 0. The
  contents of the log can be accessed by reading the /proc/spl/kstat/zfs/dbgmsg
  file. Writing 0 to this proc file clears the log.
<div class="Pp"></div>
This setting does not influence debug prints due to <b>zfs_flags</b> settings.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dbgmsg_maxsize</b> (int)
<div class="Bd-indent">The maximum size in bytes of the internal ZFS debug log.
<div class="Pp"></div>
Default value: <b>4M</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dbuf_state_index</b> (int)
<div class="Bd-indent">This feature is currently unused. It is normally used for
  controlling what reporting is available under /proc/spl/kstat/zfs.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_deadman_enabled</b> (int)
<div class="Bd-indent">When a pool sync operation takes longer than
  <b>zfs_deadman_synctime_ms</b> milliseconds, or when an individual I/O takes
  longer than <b>zfs_deadman_ziotime_ms</b> milliseconds, then the operation is
  considered to be &quot;hung&quot;. If <b>zfs_deadman_enabled</b> is set then
  the deadman behavior is invoked as described by the
  <b>zfs_deadman_failmode</b> module option. By default the deadman is enabled
  and configured to <b>wait</b> which results in &quot;hung&quot; I/Os only
  being logged. The deadman is automatically disabled when a pool gets
  suspended.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_deadman_failmode</b> (charp)
<div class="Bd-indent">Controls the failure behavior when the deadman detects a
  &quot;hung&quot; I/O. Valid values are <b>wait</b>, <b>continue</b>, and
  <b>panic</b>.
<div class="Pp"></div>
<b>wait</b> - Wait for a &quot;hung&quot; I/O to complete. For each
  &quot;hung&quot; I/O a &quot;deadman&quot; event will be posted describing
  that I/O.
<div class="Pp"></div>
<b>continue</b> - Attempt to recover from a &quot;hung&quot; I/O by
  re-dispatching it to the I/O pipeline if possible.
<div class="Pp"></div>
<b>panic</b> - Panic the system. This can be used to facilitate an automatic
  fail-over to a properly configured fail-over partner.
<div class="Pp"></div>
Default value: <b>wait</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_deadman_checktime_ms</b> (int)
<div class="Bd-indent">Check time in milliseconds. This defines the frequency at
  which we check for hung I/O and potentially invoke the
  <b>zfs_deadman_failmode</b> behavior.
<div class="Pp"></div>
Default value: <b>60,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_deadman_synctime_ms</b> (ulong)
<div class="Bd-indent">Interval in milliseconds after which the deadman is
  triggered and also the interval after which a pool sync operation is
  considered to be &quot;hung&quot;. Once this limit is exceeded the deadman
  will be invoked every <b>zfs_deadman_checktime_ms</b> milliseconds until the
  pool sync completes.
<div class="Pp"></div>
Default value: <b>600,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_deadman_ziotime_ms</b> (ulong)
<div class="Bd-indent">Interval in milliseconds after which the deadman is
  triggered and an individual I/O operation is considered to be
  &quot;hung&quot;. As long as the I/O remains &quot;hung&quot; the deadman will
  be invoked every <b>zfs_deadman_checktime_ms</b> milliseconds until the I/O
  completes.
<div class="Pp"></div>
Default value: <b>300,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dedup_prefetch</b> (int)
<div class="Bd-indent">Enable prefetching dedup-ed blks
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> to disable (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_delay_min_dirty_percent</b> (int)
<div class="Bd-indent">Start to delay each transaction once there is this amount
  of dirty data, expressed as a percentage of <b>zfs_dirty_data_max</b>. This
  value should be &gt;= zfs_vdev_async_write_active_max_dirty_percent. See the
  section &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Default value: <b>60</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_delay_scale</b> (int)
<div class="Bd-indent">This controls how quickly the transaction delay
  approaches infinity. Larger values cause longer delays for a given amount of
  dirty data.
<div class="Pp"></div>
For the smoothest delay, this value should be about 1 billion divided by the
  maximum number of operations per second. This will smoothly handle between 10x
  and 1/10th this number.
<div class="Pp"></div>
See the section &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Note: <b>zfs_delay_scale</b> * <b>zfs_dirty_data_max</b> must be &lt; 2^64.
<div class="Pp"></div>
Default value: <b>500,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_disable_ivset_guid_check</b> (int)
<div class="Bd-indent">Disables requirement for IVset guids to be present and
  match when doing a raw receive of encrypted datasets. Intended for users whose
  pools were created with OpenZFS pre-release versions and now have
  compatibility issues.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_key_max_salt_uses</b> (ulong)
<div class="Bd-indent">Maximum number of uses of a single salt value before
  generating a new one for encrypted datasets. The default value is also the
  maximum that will be accepted.
<div class="Pp"></div>
Default value: <b>400,000,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_object_mutex_size</b> (uint)
<div class="Bd-indent">Size of the znode hashtable used for holds.
<div class="Pp"></div>
Due to the need to hold locks on objects that may not exist yet, kernel mutexes
  are not created per-object and instead a hashtable is used where collisions
  will result in objects waiting when there is not actually contention on the
  same object.
<div class="Pp"></div>
Default value: <b>64</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_slow_io_events_per_second</b> (int)
<div class="Bd-indent">Rate limit delay and deadman zevents (which report slow
  I/Os) to this many per second.
<div class="Pp"></div>
Default value: 20</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unflushed_max_mem_amt</b> (ulong)
<div class="Bd-indent">Upper-bound limit for unflushed metadata changes to be
  held by the log spacemap in memory (in bytes).
<div class="Pp"></div>
Default value: <b>1,073,741,824</b> (1GB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unflushed_max_mem_ppm</b> (ulong)
<div class="Bd-indent">Percentage of the overall system memory that ZFS allows
  to be used for unflushed metadata changes by the log spacemap. (value is
  calculated over 1000000 for finer granularity).
<div class="Pp"></div>
Default value: <b>1000</b> (which is divided by 1000000, resulting in the limit
  to be <b>0.1</b>% of memory)</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unflushed_log_block_max</b> (ulong)
<div class="Bd-indent">Describes the maximum number of log spacemap blocks
  allowed for each pool. The default value of 262144 means that the space in all
  the log spacemaps can add up to no more than 262144 blocks (which means 32GB
  of logical space before compression and ditto blocks, assuming that blocksize
  is 128k).
<div class="Pp"></div>
This tunable is important because it involves a trade-off between import time
  after an unclean export and the frequency of flushing metaslabs. The higher
  this number is, the more log blocks we allow when the pool is active which
  means that we flush metaslabs less often and thus decrease the number of I/Os
  for spacemap updates per TXG. At the same time though, that means that in the
  event of an unclean export, there will be more log spacemap blocks for us to
  read, inducing overhead in the import time of the pool. The lower the number,
  the amount of flushing increases destroying log blocks quicker as they become
  obsolete faster, which leaves less blocks to be read during import time after
  a crash.
<div class="Pp"></div>
Each log spacemap block existing during pool import leads to approximately one
  extra logical I/O issued. This is the reason why this tunable is exposed in
  terms of blocks rather than space used.
<div class="Pp"></div>
Default value: <b>262144</b> (256K).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unflushed_log_block_min</b> (ulong)
<div class="Bd-indent">If the number of metaslabs is small and our incoming rate
  is high, we could get into a situation that we are flushing all our metaslabs
  every TXG. Thus we always allow at least this many log blocks.
<div class="Pp"></div>
Default value: <b>1000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unflushed_log_block_pct</b> (ulong)
<div class="Bd-indent">Tunable used to determine the number of blocks that can
  be used for the spacemap log, expressed as a percentage of the total number of
  metaslabs in the pool.
<div class="Pp"></div>
Default value: <b>400</b> (read as <b>400</b>% - meaning that the number of log
  spacemap blocks are capped at 4 times the number of metaslabs in the
  pool).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_unlink_suspend_progress</b> (uint)
<div class="Bd-indent">When enabled, files will not be asynchronously removed
  from the list of pending unlinks and the space they consume will be leaked.
  Once this option has been disabled and the dataset is remounted, the pending
  unlinks will be processed and the freed space returned to the pool. This
  option is used by the test suite to facilitate testing.
<div class="Pp"></div>
Uses <b>0</b> (default) to allow progress and <b>1</b> to pause progress.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_delete_blocks</b> (ulong)
<div class="Bd-indent">This is the used to define a large file for the purposes
  of delete. Files containing more than <b>zfs_delete_blocks</b> will be deleted
  asynchronously while smaller files are deleted synchronously. Decreasing this
  value will reduce the time spent in an unlink(2) system call at the expense of
  a longer delay before the freed space is available.
<div class="Pp"></div>
Default value: <b>20,480</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dirty_data_max</b> (int)
<div class="Bd-indent">Determines the dirty space limit in bytes. Once this
  limit is exceeded, new writes are halted until space frees up. This parameter
  takes precedence over <b>zfs_dirty_data_max_percent</b>. See the section
  &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Default value: <b>10</b>% of physical RAM, capped at
  <b>zfs_dirty_data_max_max</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dirty_data_max_max</b> (int)
<div class="Bd-indent">Maximum allowable value of <b>zfs_dirty_data_max</b>,
  expressed in bytes. This limit is only enforced at module load time, and will
  be ignored if <b>zfs_dirty_data_max</b> is later changed. This parameter takes
  precedence over <b>zfs_dirty_data_max_max_percent</b>. See the section
  &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Default value: <b>25</b>% of physical RAM.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dirty_data_max_max_percent</b> (int)
<div class="Bd-indent">Maximum allowable value of <b>zfs_dirty_data_max</b>,
  expressed as a percentage of physical RAM. This limit is only enforced at
  module load time, and will be ignored if <b>zfs_dirty_data_max</b> is later
  changed. The parameter <b>zfs_dirty_data_max_max</b> takes precedence over
  this one. See the section &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Default value: <b>25</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dirty_data_max_percent</b> (int)
<div class="Bd-indent">Determines the dirty space limit, expressed as a
  percentage of all memory. Once this limit is exceeded, new writes are halted
  until space frees up. The parameter <b>zfs_dirty_data_max</b> takes precedence
  over this one. See the section &quot;ZFS TRANSACTION DELAY&quot;.
<div class="Pp"></div>
Default value: <b>10</b>%, subject to <b>zfs_dirty_data_max_max</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dirty_data_sync_percent</b> (int)
<div class="Bd-indent">Start syncing out a transaction group if there's at least
  this much dirty data as a percentage of <b>zfs_dirty_data_max</b>. This should
  be less than <b>zfs_vdev_async_write_active_min_dirty_percent</b>.
<div class="Pp"></div>
Default value: <b>20</b>% of <b>zfs_dirty_data_max</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_fallocate_reserve_percent</b> (uint)
<div class="Bd-indent">Since ZFS is a copy-on-write filesystem with snapshots,
  blocks cannot be preallocated for a file in order to guarantee that later
  writes will not run out of space. Instead, fallocate() space preallocation
  only checks that sufficient space is currently available in the pool or the
  user's project quota allocation, and then creates a sparse file of the
  requested size. The requested space is multiplied by
  <b>zfs_fallocate_reserve_percent</b> to allow additional space for indirect
  blocks and other internal metadata. Setting this value to 0 disables support
  for fallocate(2) and returns EOPNOTSUPP for fallocate() space preallocation
  again.
<div class="Pp"></div>
Default value: <b>110</b>%</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_fletcher_4_impl</b> (string)
<div class="Bd-indent">Select a fletcher 4 implementation.
<div class="Pp"></div>
Supported selectors are: <b>fastest</b>, <b>scalar</b>, <b>sse2</b>,
  <b>ssse3</b>, <b>avx2</b>, <b>avx512f</b>, <b>avx512bw</b>, and
  <b>aarch64_neon</b>. All of the selectors except <b>fastest</b> and
  <b>scalar</b> require instruction set extensions to be available and will only
  appear if ZFS detects that they are present at runtime. If multiple
  implementations of fletcher 4 are available, the <b>fastest</b> will be chosen
  using a micro benchmark. Selecting <b>scalar</b> results in the original, CPU
  based calculation, being used. Selecting any option other than <b>fastest</b>
  and <b>scalar</b> results in vector instructions from the respective CPU
  instruction set being used.
<div class="Pp"></div>
Default value: <b>fastest</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_free_bpobj_enabled</b> (int)
<div class="Bd-indent">Enable/disable the processing of the free_bpobj object.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_async_block_max_blocks</b> (ulong)
<div class="Bd-indent">Maximum number of blocks freed in a single txg.
<div class="Pp"></div>
Default value: <b>ULONG_MAX</b> (unlimited).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_async_dedup_frees</b> (ulong)
<div class="Bd-indent">Maximum number of dedup blocks freed in a single txg.
<div class="Pp"></div>
Default value: <b>100,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_override_estimate_recordsize</b> (ulong)
<div class="Bd-indent">Record size calculation override for zfs send estimates.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_read_max_active</b> (int)
<div class="Bd-indent">Maximum asynchronous read I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>3</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_read_min_active</b> (int)
<div class="Bd-indent">Minimum asynchronous read I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_write_active_max_dirty_percent</b> (int)
<div class="Bd-indent">When the pool has more than
  <b>zfs_vdev_async_write_active_max_dirty_percent</b> dirty data, use
  <b>zfs_vdev_async_write_max_active</b> to limit active async writes. If the
  dirty data is between min and max, the active I/O limit is linearly
  interpolated. See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>60</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_write_active_min_dirty_percent</b> (int)
<div class="Bd-indent">When the pool has less than
  <b>zfs_vdev_async_write_active_min_dirty_percent</b> dirty data, use
  <b>zfs_vdev_async_write_min_active</b> to limit active async writes. If the
  dirty data is between min and max, the active I/O limit is linearly
  interpolated. See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>30</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_write_max_active</b> (int)
<div class="Bd-indent">Maximum asynchronous write I/Os active to each device.
  See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_async_write_min_active</b> (int)
<div class="Bd-indent">Minimum asynchronous write I/Os active to each device.
  See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Lower values are associated with better latency on rotational media but poorer
  resilver performance. The default value of 2 was chosen as a compromise. A
  value of 3 has been shown to improve resilver performance further at a cost of
  further increasing latency.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_initializing_max_active</b> (int)
<div class="Bd-indent">Maximum initializing I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_initializing_min_active</b> (int)
<div class="Bd-indent">Minimum initializing I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_max_active</b> (int)
<div class="Bd-indent">The maximum number of I/Os active to each device.
  Ideally, this will be &gt;= the sum of each queue's max_active. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_rebuild_max_active</b> (int)
<div class="Bd-indent">Maximum sequential resilver I/Os active to each device.
  See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>3</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_rebuild_min_active</b> (int)
<div class="Bd-indent">Minimum sequential resilver I/Os active to each device.
  See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_removal_max_active</b> (int)
<div class="Bd-indent">Maximum removal I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_removal_min_active</b> (int)
<div class="Bd-indent">Minimum removal I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_scrub_max_active</b> (int)
<div class="Bd-indent">Maximum scrub I/Os active to each device. See the section
  &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_scrub_min_active</b> (int)
<div class="Bd-indent">Minimum scrub I/Os active to each device. See the section
  &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_sync_read_max_active</b> (int)
<div class="Bd-indent">Maximum synchronous read I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_sync_read_min_active</b> (int)
<div class="Bd-indent">Minimum synchronous read I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_sync_write_max_active</b> (int)
<div class="Bd-indent">Maximum synchronous write I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_sync_write_min_active</b> (int)
<div class="Bd-indent">Minimum synchronous write I/Os active to each device. See
  the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_trim_max_active</b> (int)
<div class="Bd-indent">Maximum trim/discard I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_trim_min_active</b> (int)
<div class="Bd-indent">Minimum trim/discard I/Os active to each device. See the
  section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_nia_delay</b> (int)
<div class="Bd-indent">For non-interactive I/O (scrub, resilver, removal,
  initialize and rebuild), the number of concurrently-active I/O's is limited to
  *_min_active, unless the vdev is &quot;idle&quot;. When there are no
  interactive I/Os active (sync or async), and zfs_vdev_nia_delay I/Os have
  completed since the last interactive I/O, then the vdev is considered to be
  &quot;idle&quot;, and the number of concurrently-active non-interactive I/O's
  is increased to *_max_active. See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_nia_credit</b> (int)
<div class="Bd-indent">Some HDDs tend to prioritize sequential I/O so high, that
  concurrent random I/O latency reaches several seconds. On some HDDs it happens
  even if sequential I/Os are submitted one at a time, and so setting
  *_max_active to 1 does not help. To prevent non-interactive I/Os, like scrub,
  from monopolizing the device no more than zfs_vdev_nia_credit I/Os can be sent
  while there are outstanding incomplete interactive I/Os. This enforced wait
  ensures the HDD services the interactive I/O within a reasonable amount of
  time. See the section &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_queue_depth_pct</b> (int)
<div class="Bd-indent">Maximum number of queued allocations per top-level vdev
  expressed as a percentage of <b>zfs_vdev_async_write_max_active</b> which
  allows the system to detect devices that are more capable of handling
  allocations and to allocate more blocks to those devices. It allows for
  dynamic allocation distribution when devices are imbalanced as fuller devices
  will tend to be slower than empty devices.
<div class="Pp"></div>
See also <b>zio_dva_throttle_enabled</b>.
<div class="Pp"></div>
Default value: <b>1000</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_expire_snapshot</b> (int)
<div class="Bd-indent">Seconds to expire .zfs/snapshot
<div class="Pp"></div>
Default value: <b>300</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_admin_snapshot</b> (int)
<div class="Bd-indent">Allow the creation, removal, or renaming of entries in
  the .zfs/snapshot directory to cause the creation, destruction, or renaming of
  snapshots. When enabled this functionality works both locally and over NFS
  exports which have the 'no_root_squash' option set. This functionality is
  disabled by default.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_flags</b> (int)
<div class="Bd-indent">Set additional debugging flags. The following flags may
  be bitwise-or'd together.
<div class="Pp"></div>
<table class="tbl">
  <tr>
    <td>Value</td>
    <td>Symbolic Name</td>
  </tr>
  <tr>
    <td></td>
    <td>Description</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>1</td>
    <td>ZFS_DEBUG_DPRINTF</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable dprintf entries in the debug log.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>2</td>
    <td>ZFS_DEBUG_DBUF_VERIFY *</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable extra dbuf verifications.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>4</td>
    <td>ZFS_DEBUG_DNODE_VERIFY *</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable extra dnode verifications.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>8</td>
    <td>ZFS_DEBUG_SNAPNAMES</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable snapshot name verification.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>16</td>
    <td>ZFS_DEBUG_MODIFY</td>
  </tr>
  <tr>
    <td></td>
    <td>Check for illegally modified ARC buffers.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>64</td>
    <td>ZFS_DEBUG_ZIO_FREE</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable verification of block frees.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>128</td>
    <td>ZFS_DEBUG_HISTOGRAM_VERIFY</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable extra spacemap histogram verifications.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>256</td>
    <td>ZFS_DEBUG_METASLAB_VERIFY</td>
  </tr>
  <tr>
    <td></td>
    <td>Verify space accounting on disk matches in-core range_trees.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>512</td>
    <td>ZFS_DEBUG_SET_ERROR</td>
  </tr>
  <tr>
    <td></td>
    <td>Enable SET_ERROR and dprintf entries in the debug log.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>1024</td>
    <td>ZFS_DEBUG_INDIRECT_REMAP</td>
  </tr>
  <tr>
    <td></td>
    <td>Verify split blocks created by device removal.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>2048</td>
    <td>ZFS_DEBUG_TRIM</td>
  </tr>
  <tr>
    <td></td>
    <td>Verify TRIM ranges are always within the allocatable range tree.</td>
  </tr>
  <tr>
    <td colspan="0"></td>
  </tr>
  <tr>
    <td>4096</td>
    <td>ZFS_DEBUG_LOG_SPACEMAP</td>
  </tr>
  <tr>
    <td></td>
    <td>Verify that the log summary is consistent with the spacemap log</td>
  </tr>
  <tr>
    <td></td>
    <td>and enable zfs_dbgmsgs for metaslab loading and flushing.</td>
  </tr>
</table>
<div class="Pp"></div>
* Requires debug build.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_free_leak_on_eio</b> (int)
<div class="Bd-indent">If destroy encounters an EIO while reading metadata (e.g.
  indirect blocks), space referenced by the missing metadata can not be freed.
  Normally this causes the background destroy to become &quot;stalled&quot;, as
  it is unable to make forward progress. While in this stalled state, all
  remaining space to free from the error-encountering filesystem is
  &quot;temporarily leaked&quot;. Set this flag to cause it to ignore the EIO,
  permanently leak the space from indirect blocks that can not be read, and
  continue to free everything else that it can.
<div class="Pp"></div>
The default, &quot;stalling&quot; behavior is useful if the storage partially
  fails (i.e. some but not all i/os fail), and then later recovers. In this
  case, we will be able to continue pool operations while it is partially
  failed, and when it recovers, we can continue to free the space, with no
  leaks. However, note that this case is actually fairly rare.
<div class="Pp"></div>
Typically pools either (a) fail completely (but perhaps temporarily, e.g. a
  top-level vdev going offline), or (b) have localized, permanent errors (e.g.
  disk returns the wrong data due to bit flip or firmware bug). In case (a),
  this setting does not matter because the pool will be suspended and the sync
  thread will not be able to make forward progress regardless. In case (b),
  because the error is permanent, the best we can do is leak the minimum amount
  of space, which is what setting this flag will do. Therefore, it is reasonable
  for this flag to normally be set, but we chose the more conservative approach
  of not setting it, so that there is no possibility of leaking space in the
  &quot;partial temporary&quot; failure case.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_free_min_time_ms</b> (int)
<div class="Bd-indent">During a <b>zfs destroy</b> operation using
  <b>feature@async_destroy</b> a minimum of this much time will be spent working
  on freeing blocks per txg.
<div class="Pp"></div>
Default value: <b>1,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_obsolete_min_time_ms</b> (int)
<div class="Bd-indent">Similar to <b>zfs_free_min_time_ms</b> but for cleanup of
  old indirection records for removed vdevs.
<div class="Pp"></div>
Default value: <b>500</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_immediate_write_sz</b> (long)
<div class="Bd-indent">Largest data block to write to zil. Larger blocks will be
  treated as if the dataset being written to had the property setting
  <b>logbias=throughput</b>.
<div class="Pp"></div>
Default value: <b>32,768</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_initialize_value</b> (ulong)
<div class="Bd-indent">Pattern written to vdev free space by <b>zpool
  initialize</b>.
<div class="Pp"></div>
Default value: <b>16,045,690,984,833,335,022</b> (0xdeadbeefdeadbeee).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_initialize_chunk_size</b> (ulong)
<div class="Bd-indent">Size of writes used by <b>zpool initialize</b>. This
  option is used by the test suite to facilitate testing.
<div class="Pp"></div>
Default value: <b>1,048,576</b></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_max_entries</b> (ulong)
<div class="Bd-indent">The threshold size (in block pointers) at which we create
  a new sub-livelist. Larger sublists are more costly from a memory perspective
  but the fewer sublists there are, the lower the cost of insertion.
<div class="Pp"></div>
Default value: <b>500,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_min_percent_shared</b> (int)
<div class="Bd-indent">If the amount of shared space between a snapshot and its
  clone drops below this threshold, the clone turns off the livelist and reverts
  to the old deletion method. This is in place because once a clone has been
  overwritten enough livelists no long give us a benefit.
<div class="Pp"></div>
Default value: <b>75</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_condense_new_alloc</b> (int)
<div class="Bd-indent">Incremented each time an extra ALLOC blkptr is added to a
  livelist entry while it is being condensed. This option is used by the test
  suite to track race conditions.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_condense_sync_cancel</b> (int)
<div class="Bd-indent">Incremented each time livelist condensing is canceled
  while in spa_livelist_condense_sync. This option is used by the test suite to
  track race conditions.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_condense_sync_pause</b> (int)
<div class="Bd-indent">When set, the livelist condense process pauses
  indefinitely before executing the synctask - spa_livelist_condense_sync. This
  option is used by the test suite to trigger race conditions.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_condense_zthr_cancel</b> (int)
<div class="Bd-indent">Incremented each time livelist condensing is canceled
  while in spa_livelist_condense_cb. This option is used by the test suite to
  track race conditions.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_livelist_condense_zthr_pause</b> (int)
<div class="Bd-indent">When set, the livelist condense process pauses
  indefinitely before executing the open context condensing work in
  spa_livelist_condense_cb. This option is used by the test suite to trigger
  race conditions.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_lua_max_instrlimit</b> (ulong)
<div class="Bd-indent">The maximum execution time limit that can be set for a
  ZFS channel program, specified as a number of Lua instructions.
<div class="Pp"></div>
Default value: <b>100,000,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_lua_max_memlimit</b> (ulong)
<div class="Bd-indent">The maximum memory limit that can be set for a ZFS
  channel program, specified in bytes.
<div class="Pp"></div>
Default value: <b>104,857,600</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_dataset_nesting</b> (int)
<div class="Bd-indent">The maximum depth of nested datasets. This value can be
  tuned temporarily to fix existing datasets that exceed the predefined limit.
<div class="Pp"></div>
Default value: <b>50</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_log_walking</b> (ulong)
<div class="Bd-indent">The number of past TXGs that the flushing algorithm of
  the log spacemap feature uses to estimate incoming log blocks.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_logsm_summary_length</b> (ulong)
<div class="Bd-indent">Maximum number of rows allowed in the summary of the
  spacemap log.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_max_recordsize</b> (int)
<div class="Bd-indent">We currently support block sizes from 512 bytes to 16MB.
  The benefits of larger blocks, and thus larger I/O, need to be weighed against
  the cost of COWing a giant block to modify one byte. Additionally, very large
  blocks can have an impact on i/o latency, and also potentially on the memory
  allocator. Therefore, we do not allow the recordsize to be set larger than
  zfs_max_recordsize (default 1MB). Larger blocks can be created by changing
  this tunable, and pools with larger blocks can always be imported and used,
  regardless of this setting.
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_allow_redacted_dataset_mount</b> (int)
<div class="Bd-indent">Allow datasets received with redacted send/receive to be
  mounted. Normally disabled because these datasets may be missing key data.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_min_metaslabs_to_flush</b> (ulong)
<div class="Bd-indent">Minimum number of metaslabs to flush per dirty TXG
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_metaslab_fragmentation_threshold</b> (int)
<div class="Bd-indent">Allow metaslabs to keep their active state as long as
  their fragmentation percentage is less than or equal to this value. An active
  metaslab that exceeds this threshold will no longer keep its active status
  allowing better metaslabs to be selected.
<div class="Pp"></div>
Default value: <b>70</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_mg_fragmentation_threshold</b> (int)
<div class="Bd-indent">Metaslab groups are considered eligible for allocations
  if their fragmentation metric (measured as a percentage) is less than or equal
  to this value. If a metaslab group exceeds this threshold then it will be
  skipped unless all metaslab groups within the metaslab class have also crossed
  this threshold.
<div class="Pp"></div>
Default value: <b>95</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_mg_noalloc_threshold</b> (int)
<div class="Bd-indent">Defines a threshold at which metaslab groups should be
  eligible for allocations. The value is expressed as a percentage of free space
  beyond which a metaslab group is always eligible for allocations. If a
  metaslab group's free space is less than or equal to the threshold, the
  allocator will avoid allocating to that group unless all groups in the pool
  have reached the threshold. Once all groups have reached the threshold, all
  groups are allowed to accept allocations. The default value of 0 disables the
  feature and causes all metaslab groups to be eligible for allocations.
<div class="Pp"></div>
This parameter allows one to deal with pools having heavily imbalanced vdevs
  such as would be the case when a new vdev has been added. Setting the
  threshold to a non-zero percentage will stop allocations from being made to
  vdevs that aren't filled to the specified percentage and allow lesser filled
  vdevs to acquire more allocations than they otherwise would under the old
  <b>zfs_mg_alloc_failures</b> facility.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_ddt_data_is_special</b> (int)
<div class="Bd-indent">If enabled, ZFS will place DDT data into the special
  allocation class.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_user_indirect_is_special</b> (int)
<div class="Bd-indent">If enabled, ZFS will place user data (both file and zvol)
  indirect blocks into the special allocation class.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_multihost_history</b> (int)
<div class="Bd-indent">Historical statistics for the last N multihost updates
  will be available in <b>/proc/spl/kstat/zfs/&lt;pool&gt;/multihost</b>
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_multihost_interval</b> (ulong)
<div class="Bd-indent">Used to control the frequency of multihost writes which
  are performed when the <b>multihost</b> pool property is on. This is one
  factor used to determine the length of the activity check during import.
<div class="Pp"></div>
The multihost write period is <b>zfs_multihost_interval / leaf-vdevs</b>
  milliseconds. On average a multihost write will be issued for each leaf vdev
  every <b>zfs_multihost_interval</b> milliseconds. In practice, the observed
  period can vary with the I/O load and this observed value is the delay which
  is stored in the uberblock.
<div class="Pp"></div>
Default value: <b>1000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_multihost_import_intervals</b> (uint)
<div class="Bd-indent">Used to control the duration of the activity test on
  import. Smaller values of <b>zfs_multihost_import_intervals</b> will reduce
  the import time but increase the risk of failing to detect an active pool. The
  total activity check time is never allowed to drop below one second.
<div class="Pp"></div>
On import the activity check waits a minimum amount of time determined by
  <b>zfs_multihost_interval * zfs_multihost_import_intervals</b>, or the same
  product computed on the host which last had the pool imported (whichever is
  greater). The activity check time may be further extended if the value of mmp
  delay found in the best uberblock indicates actual multihost updates happened
  at longer intervals than <b>zfs_multihost_interval</b>. A minimum value of
  <b>100ms</b> is enforced.
<div class="Pp"></div>
A value of 0 is ignored and treated as if it was set to 1.
<div class="Pp"></div>
Default value: <b>20</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_multihost_fail_intervals</b> (uint)
<div class="Bd-indent">Controls the behavior of the pool when multihost write
  failures or delays are detected.
<div class="Pp"></div>
When <b>zfs_multihost_fail_intervals = 0</b>, multihost write failures or delays
  are ignored. The failures will still be reported to the ZED which depending on
  its configuration may take action such as suspending the pool or offlining a
  device.
<div class="Pp"></div>
<div class="Pp"></div>
When <b>zfs_multihost_fail_intervals &gt; 0</b>, the pool will be suspended if
  <b>zfs_multihost_fail_intervals * zfs_multihost_interval</b> milliseconds pass
  without a successful mmp write. This guarantees the activity test will see mmp
  writes if the pool is imported. A value of 1 is ignored and treated as if it
  was set to 2. This is necessary to prevent the pool from being suspended due
  to normal, small I/O latency variations.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_no_scrub_io</b> (int)
<div class="Bd-indent">Set for no scrub I/O. This results in scrubs not actually
  scrubbing data and simply doing a metadata crawl of the pool instead.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_no_scrub_prefetch</b> (int)
<div class="Bd-indent">Set to disable block prefetching for scrubs.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_nocacheflush</b> (int)
<div class="Bd-indent">Disable cache flush operations on disks when writing.
  Setting this will cause pool corruption on power loss if a volatile
  out-of-order write cache is enabled.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_nopwrite_enabled</b> (int)
<div class="Bd-indent">Enable NOP writes
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> to disable.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_dmu_offset_next_sync</b> (int)
<div class="Bd-indent">Enable forcing txg sync to find holes. When enabled
  forces ZFS to act like prior versions when SEEK_HOLE or SEEK_DATA flags are
  used, which when a dnode is dirty causes txg's to be synced so that this data
  can be found.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> to disable (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_pd_bytes_max</b> (int)
<div class="Bd-indent">The number of bytes which should be prefetched during a
  pool traversal (eg: <b>zfs send</b> or other data crawling operations)
<div class="Pp"></div>
Default value: <b>52,428,800</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_traverse_indirect_prefetch_limit</b> (int)
<div class="Bd-indent">The number of blocks pointed by indirect (non-L0) block,
  which should be prefetched during a pool traversal (eg: <b>zfs send</b> or
  other data crawling operations)
<div class="Pp"></div>
Default value: <b>32</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_per_txg_dirty_frees_percent </b> (ulong)
<div class="Bd-indent">Tunable to control percentage of dirtied indirect blocks
  from frees allowed into one TXG. After this threshold is crossed, additional
  frees will wait until the next TXG. A value of zero will disable this
  throttle.
<div class="Pp"></div>
Default value: <b>5</b>, set to <b>0</b> to disable.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_prefetch_disable</b> (int)
<div class="Bd-indent">This tunable disables predictive prefetch. Note that it
  leaves &quot;prescient&quot; prefetch (e.g. prefetch for zfs send) intact.
  Unlike predictive prefetch, prescient prefetch never issues i/os that end up
  not being needed, so it can't hurt performance.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_qat_checksum_disable</b> (int)
<div class="Bd-indent">This tunable disables qat hardware acceleration for
  sha256 checksums. It may be set after the zfs modules have been loaded to
  initialize the qat hardware as long as support is compiled in and the qat
  driver is present.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_qat_compress_disable</b> (int)
<div class="Bd-indent">This tunable disables qat hardware acceleration for gzip
  compression. It may be set after the zfs modules have been loaded to
  initialize the qat hardware as long as support is compiled in and the qat
  driver is present.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_qat_encrypt_disable</b> (int)
<div class="Bd-indent">This tunable disables qat hardware acceleration for
  AES-GCM encryption. It may be set after the zfs modules have been loaded to
  initialize the qat hardware as long as support is compiled in and the qat
  driver is present.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vnops_read_chunk_size</b> (long)
<div class="Bd-indent">Bytes to read per chunk
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_read_history</b> (int)
<div class="Bd-indent">Historical statistics for the last N reads will be
  available in <b>/proc/spl/kstat/zfs/&lt;pool&gt;/reads</b>
<div class="Pp"></div>
Default value: <b>0</b> (no data is kept).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_read_history_hits</b> (int)
<div class="Bd-indent">Include cache hits in read history
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_rebuild_max_segment</b> (ulong)
<div class="Bd-indent">Maximum read segment size to issue when sequentially
  resilvering a top-level vdev.
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_rebuild_scrub_enabled</b> (int)
<div class="Bd-indent">Automatically start a pool scrub when the last active
  sequential resilver completes in order to verify the checksums of all blocks
  which have been resilvered. This option is enabled by default and is strongly
  recommended.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_rebuild_vdev_limit</b> (ulong)
<div class="Bd-indent">Maximum amount of i/o that can be concurrently issued for
  a sequential resilver per leaf device, given in bytes.
<div class="Pp"></div>
Default value: <b>33,554,432</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_reconstruct_indirect_combinations_max</b> (int)
<div class="Bd-indent">If an indirect split block contains more than this many
  possible unique combinations when being reconstructed, consider it too
  computationally expensive to check them all. Instead, try at most
  <b>zfs_reconstruct_indirect_combinations_max</b> randomly-selected
  combinations each time the block is accessed. This allows all segment copies
  to participate fairly in the reconstruction when all combinations cannot be
  checked and prevents repeated use of one bad copy.
<div class="Pp"></div>
Default value: <b>4096</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_recover</b> (int)
<div class="Bd-indent">Set to attempt to recover from fatal errors. This should
  only be used as a last resort, as it typically results in leaked space, or
  worse.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_removal_ignore_errors</b> (int)
<div class="Bd-indent">
<div class="Pp"></div>
Ignore hard IO errors during device removal. When set, if a device encounters a
  hard IO error during the removal process the removal will not be cancelled.
  This can result in a normally recoverable block becoming permanently damaged
  and is not recommended. This should only be used as a last resort when the
  pool cannot be returned to a healthy state prior to removing the device.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_removal_suspend_progress</b> (int)
<div class="Bd-indent">
<div class="Pp"></div>
This is used by the test suite so that it can ensure that certain actions happen
  while in the middle of a removal.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_remove_max_segment</b> (int)
<div class="Bd-indent">
<div class="Pp"></div>
The largest contiguous segment that we will attempt to allocate when removing a
  device. This can be no larger than 16MB. If there is a performance problem
  with attempting to allocate large blocks, consider decreasing this.
<div class="Pp"></div>
Default value: <b>16,777,216</b> (16MB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_resilver_disable_defer</b> (int)
<div class="Bd-indent">Disables the <b>resilver_defer</b> feature, causing an
  operation that would start a resilver to restart one in progress immediately.
<div class="Pp"></div>
Default value: <b>0</b> (feature enabled).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_resilver_min_time_ms</b> (int)
<div class="Bd-indent">Resilvers are processed by the sync thread. While
  resilvering it will spend at least this much time working on a resilver
  between txg flushes.
<div class="Pp"></div>
Default value: <b>3,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_ignore_errors</b> (int)
<div class="Bd-indent">If set to a nonzero value, remove the DTL (dirty time
  list) upon completion of a pool scan (scrub) even if there were unrepairable
  errors. It is intended to be used during pool repair or recovery to stop
  resilvering when the pool is next imported.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scrub_min_time_ms</b> (int)
<div class="Bd-indent">Scrubs are processed by the sync thread. While scrubbing
  it will spend at least this much time working on a scrub between txg flushes.
<div class="Pp"></div>
Default value: <b>1,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_checkpoint_intval</b> (int)
<div class="Bd-indent">To preserve progress across reboots the sequential scan
  algorithm periodically needs to stop metadata scanning and issue all the
  verifications I/Os to disk. The frequency of this flushing is determined by
  the <b>zfs_scan_checkpoint_intval</b> tunable.
<div class="Pp"></div>
Default value: <b>7200</b> seconds (every 2 hours).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_fill_weight</b> (int)
<div class="Bd-indent">This tunable affects how scrub and resilver I/O segments
  are ordered. A higher number indicates that we care more about how filled in a
  segment is, while a lower number indicates we care more about the size of the
  extent without considering the gaps within a segment. This value is only
  tunable upon module insertion. Changing the value afterwards will have no
  affect on scrub or resilver performance.
<div class="Pp"></div>
Default value: <b>3</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_issue_strategy</b> (int)
<div class="Bd-indent">Determines the order that data will be verified while
  scrubbing or resilvering. If set to <b>1</b>, data will be verified as
  sequentially as possible, given the amount of memory reserved for scrubbing
  (see <b>zfs_scan_mem_lim_fact</b>). This may improve scrub performance if the
  pool's data is very fragmented. If set to <b>2</b>, the largest
  mostly-contiguous chunk of found data will be verified first. By deferring
  scrubbing of small segments, we may later find adjacent data to coalesce and
  increase the segment size. If set to <b>0</b>, zfs will use strategy <b>1</b>
  during normal verification and strategy <b>2</b> while taking a checkpoint.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_legacy</b> (int)
<div class="Bd-indent">A value of 0 indicates that scrubs and resilvers will
  gather metadata in memory before issuing sequential I/O. A value of 1
  indicates that the legacy algorithm will be used where I/O is initiated as
  soon as it is discovered. Changing this value to 0 will not affect scrubs or
  resilvers that are already in progress.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_max_ext_gap</b> (int)
<div class="Bd-indent">Indicates the largest gap in bytes between scrub /
  resilver I/Os that will still be considered sequential for sorting purposes.
  Changing this value will not affect scrubs or resilvers that are already in
  progress.
<div class="Pp"></div>
Default value: <b>2097152 (2 MB)</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_mem_lim_fact</b> (int)
<div class="Bd-indent">Maximum fraction of RAM used for I/O sorting by
  sequential scan algorithm. This tunable determines the hard limit for I/O
  sorting memory usage. When the hard limit is reached we stop scanning metadata
  and start issuing data verification I/O. This is done until we get below the
  soft limit.
<div class="Pp"></div>
Default value: <b>20</b> which is 5% of RAM (1/20).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_mem_lim_soft_fact</b> (int)
<div class="Bd-indent">The fraction of the hard limit used to determined the
  soft limit for I/O sorting by the sequential scan algorithm. When we cross
  this limit from below no action is taken. When we cross this limit from above
  it is because we are issuing verification I/O. In this case (unless the
  metadata scan is done) we stop issuing verification I/O and start scanning
  metadata again until we get to the hard limit.
<div class="Pp"></div>
Default value: <b>20</b> which is 5% of the hard limit (1/20).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_strict_mem_lim</b> (int)
<div class="Bd-indent">Enforces tight memory limits on pool scans when a
  sequential scan is in progress. When disabled the memory limit may be exceeded
  by fast disks.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_suspend_progress</b> (int)
<div class="Bd-indent">Freezes a scrub/resilver in progress without actually
  pausing it. Intended for testing/debugging.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_scan_vdev_limit</b> (int)
<div class="Bd-indent">Maximum amount of data that can be concurrently issued at
  once for scrubs and resilvers per leaf device, given in bytes.
<div class="Pp"></div>
Default value: <b>4194304</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_corrupt_data</b> (int)
<div class="Bd-indent">Allow sending of corrupt data (ignore read/checksum
  errors when sending data)
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_unmodified_spill_blocks</b> (int)
<div class="Bd-indent">Include unmodified spill blocks in the send stream. Under
  certain circumstances previous versions of ZFS could incorrectly remove the
  spill block from an existing object. Including unmodified copies of the spill
  blocks creates a backwards compatible stream which will recreate a spill block
  if it was incorrectly removed.
<div class="Pp"></div>
Use <b>1</b> for yes (default) and <b>0</b> for no.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_no_prefetch_queue_ff</b> (int)
<div class="Bd-indent">The fill fraction of the <b>zfs send</b> internal queues.
  The fill fraction controls the timing with which internal threads are woken
  up.
<div class="Pp"></div>
Default value: <b>20</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_no_prefetch_queue_length</b> (int)
<div class="Bd-indent">The maximum number of bytes allowed in <b>zfs send</b>'s
  internal queues.
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_queue_ff</b> (int)
<div class="Bd-indent">The fill fraction of the <b>zfs send</b> prefetch queue.
  The fill fraction controls the timing with which internal threads are woken
  up.
<div class="Pp"></div>
Default value: <b>20</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_send_queue_length</b> (int)
<div class="Bd-indent">The maximum number of bytes allowed that will be
  prefetched by <b>zfs send</b>. This value must be at least twice the maximum
  block size in use.
<div class="Pp"></div>
Default value: <b>16,777,216</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_recv_queue_ff</b> (int)
<div class="Bd-indent">The fill fraction of the <b>zfs receive</b> queue. The
  fill fraction controls the timing with which internal threads are woken up.
<div class="Pp"></div>
Default value: <b>20</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_recv_queue_length</b> (int)
<div class="Bd-indent">The maximum number of bytes allowed in the <b>zfs
  receive</b> queue. This value must be at least twice the maximum block size in
  use.
<div class="Pp"></div>
Default value: <b>16,777,216</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_recv_write_batch_size</b> (int)
<div class="Bd-indent">The maximum amount of data (in bytes) that <b>zfs
  receive</b> will write in one DMU transaction. This is the uncompressed size,
  even when receiving a compressed send stream. This setting will not reduce the
  write size below a single block. Capped at a maximum of 32MB
<div class="Pp"></div>
Default value: <b>1MB</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_override_estimate_recordsize</b> (ulong)
<div class="Bd-indent">Setting this variable overrides the default logic for
  estimating block sizes when doing a zfs send. The default heuristic is that
  the average block size will be the current recordsize. Override this value if
  most data in your dataset is not of that size and you require accurate zfs
  send size estimates.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_sync_pass_deferred_free</b> (int)
<div class="Bd-indent">Flushing of data to disk is done in passes. Defer frees
  starting in this pass
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_spa_discard_memory_limit</b> (int)
<div class="Bd-indent">Maximum memory used for prefetching a checkpoint's space
  map on each vdev while discarding the checkpoint.
<div class="Pp"></div>
Default value: <b>16,777,216</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_special_class_metadata_reserve_pct</b> (int)
<div class="Bd-indent">Only allow small data blocks to be allocated on the
  special and dedup vdev types when the available free space percentage on these
  vdevs exceeds this value. This ensures reserved space is available for pool
  meta data as the special vdevs approach capacity.
<div class="Pp"></div>
Default value: <b>25</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_sync_pass_dont_compress</b> (int)
<div class="Bd-indent">Starting in this sync pass, we disable compression
  (including of metadata). With the default setting, in practice, we don't have
  this many sync passes, so this has no effect.
<div class="Pp"></div>
The original intent was that disabling compression would help the sync passes to
  converge. However, in practice disabling compression increases the average
  number of sync passes, because when we turn compression off, a lot of block's
  size will change and thus we have to re-allocate (not overwrite) them. It also
  increases the number of 128KB allocations (e.g. for indirect blocks and
  spacemaps) because these will not be compressed. The 128K allocations are
  especially detrimental to performance on highly fragmented systems, which may
  have very few free segments of this size, and may need to load new metaslabs
  to satisfy 128K allocations.
<div class="Pp"></div>
Default value: <b>8</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_sync_pass_rewrite</b> (int)
<div class="Bd-indent">Rewrite new block pointers starting in this pass
<div class="Pp"></div>
Default value: <b>2</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_sync_taskq_batch_pct</b> (int)
<div class="Bd-indent">This controls the number of threads used by the
  dp_sync_taskq. The default value of 75% will create a maximum of one thread
  per cpu.
<div class="Pp"></div>
Default value: <b>75</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_trim_extent_bytes_max</b> (uint)
<div class="Bd-indent">Maximum size of TRIM command. Ranges larger than this
  will be split in to chunks no larger than <b>zfs_trim_extent_bytes_max</b>
  bytes before being issued to the device.
<div class="Pp"></div>
Default value: <b>134,217,728</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_trim_extent_bytes_min</b> (uint)
<div class="Bd-indent">Minimum size of TRIM commands. TRIM ranges smaller than
  this will be skipped unless they're part of a larger range which was broken in
  to chunks. This is done because it's common for these small TRIMs to
  negatively impact overall performance. This value can be set to 0 to TRIM all
  unallocated space.
<div class="Pp"></div>
Default value: <b>32,768</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_trim_metaslab_skip</b> (uint)
<div class="Bd-indent">Skip uninitialized metaslabs during the TRIM process.
  This option is useful for pools constructed from large thinly-provisioned
  devices where TRIM operations are slow. As a pool ages an increasing fraction
  of the pools metaslabs will be initialized progressively degrading the
  usefulness of this option. This setting is stored when starting a manual TRIM
  and will persist for the duration of the requested TRIM.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_trim_queue_limit</b> (uint)
<div class="Bd-indent">Maximum number of queued TRIMs outstanding per leaf vdev.
  The number of concurrent TRIM commands issued to the device is controlled by
  the <b>zfs_vdev_trim_min_active</b> and <b>zfs_vdev_trim_max_active</b> module
  options.
<div class="Pp"></div>
Default value: <b>10</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_trim_txg_batch</b> (uint)
<div class="Bd-indent">The number of transaction groups worth of frees which
  should be aggregated before TRIM operations are issued to the device. This
  setting represents a trade-off between issuing larger, more efficient TRIM
  operations and the delay before the recently trimmed space is available for
  use by the device.
<div class="Pp"></div>
Increasing this value will allow frees to be aggregated for a longer time. This
  will result is larger TRIM operations and potentially increased memory usage.
  Decreasing this value will have the opposite effect. The default value of 32
  was determined to be a reasonable compromise.
<div class="Pp"></div>
Default value: <b>32</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_txg_history</b> (int)
<div class="Bd-indent">Historical statistics for the last N txgs will be
  available in <b>/proc/spl/kstat/zfs/&lt;pool&gt;/txgs</b>
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_txg_timeout</b> (int)
<div class="Bd-indent">Flush dirty data to disk at least every N seconds
  (maximum txg duration)
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_aggregate_trim</b> (int)
<div class="Bd-indent">Allow TRIM I/Os to be aggregated. This is normally not
  helpful because the extents to be trimmed will have been already been
  aggregated by the metaslab. This option is provided for debugging and
  performance analysis.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_aggregation_limit</b> (int)
<div class="Bd-indent">Max vdev I/O aggregation size
<div class="Pp"></div>
Default value: <b>1,048,576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_aggregation_limit_non_rotating</b> (int)
<div class="Bd-indent">Max vdev I/O aggregation size for non-rotating media
<div class="Pp"></div>
Default value: <b>131,072</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_cache_bshift</b> (int)
<div class="Bd-indent">Shift size to inflate reads too
<div class="Pp"></div>
Default value: <b>16</b> (effectively 65536).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_cache_max</b> (int)
<div class="Bd-indent">Inflate reads smaller than this value to meet the
  <b>zfs_vdev_cache_bshift</b> size (default 64k).
<div class="Pp"></div>
Default value: <b>16384</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_cache_size</b> (int)
<div class="Bd-indent">Total size of the per-disk cache in bytes.
<div class="Pp"></div>
Currently this feature is disabled as it has been found to not be helpful for
  performance and in some cases harmful.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_mirror_rotating_inc</b> (int)
<div class="Bd-indent">A number by which the balancing algorithm increments the
  load calculation for the purpose of selecting the least busy mirror member
  when an I/O immediately follows its predecessor on rotational vdevs for the
  purpose of making decisions based on load.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_mirror_rotating_seek_inc</b> (int)
<div class="Bd-indent">A number by which the balancing algorithm increments the
  load calculation for the purpose of selecting the least busy mirror member
  when an I/O lacks locality as defined by the
  zfs_vdev_mirror_rotating_seek_offset. I/Os within this that are not
  immediately following the previous I/O are incremented by half.
<div class="Pp"></div>
Default value: <b>5</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_mirror_rotating_seek_offset</b> (int)
<div class="Bd-indent">The maximum distance for the last queued I/O in which the
  balancing algorithm considers an I/O to have locality. See the section
  &quot;ZFS I/O SCHEDULER&quot;.
<div class="Pp"></div>
Default value: <b>1048576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_mirror_non_rotating_inc</b> (int)
<div class="Bd-indent">A number by which the balancing algorithm increments the
  load calculation for the purpose of selecting the least busy mirror member on
  non-rotational vdevs when I/Os do not immediately follow one another.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_mirror_non_rotating_seek_inc</b> (int)
<div class="Bd-indent">A number by which the balancing algorithm increments the
  load calculation for the purpose of selecting the least busy mirror member
  when an I/O lacks locality as defined by the
  zfs_vdev_mirror_rotating_seek_offset. I/Os within this that are not
  immediately following the previous I/O are incremented by half.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_read_gap_limit</b> (int)
<div class="Bd-indent">Aggregate read I/O operations if the gap on-disk between
  them is within this threshold.
<div class="Pp"></div>
Default value: <b>32,768</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_write_gap_limit</b> (int)
<div class="Bd-indent">Aggregate write I/O over gap
<div class="Pp"></div>
Default value: <b>4,096</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_raidz_impl</b> (string)
<div class="Bd-indent">Parameter for selecting raidz parity implementation to
  use.
<div class="Pp"></div>
Options marked (always) below may be selected on module load as they are
  supported on all systems. The remaining options may only be set after the
  module is loaded, as they are available only if the implementations are
  compiled in and supported on the running system.
<div class="Pp"></div>
Once the module is loaded, the content of
  /sys/module/zfs/parameters/zfs_vdev_raidz_impl will show available options
  with the currently selected one enclosed in []. Possible options are:
<br/>
 fastest - (always) implementation selected using built-in benchmark
<br/>
 original - (always) original raidz implementation
<br/>
 scalar - (always) scalar raidz implementation
<br/>
 sse2 - implementation using SSE2 instruction set (64bit x86 only)
<br/>
 ssse3 - implementation using SSSE3 instruction set (64bit x86 only)
<br/>
 avx2 - implementation using AVX2 instruction set (64bit x86 only)
<br/>
 avx512f - implementation using AVX512F instruction set (64bit x86 only)
<br/>
 avx512bw - implementation using AVX512F &amp; AVX512BW instruction sets (64bit
  x86 only)
<br/>
 aarch64_neon - implementation using NEON (Aarch64/64 bit ARMv8 only)
<br/>
 aarch64_neonx2 - implementation using NEON with more unrolling (Aarch64/64 bit
  ARMv8 only)
<br/>
 powerpc_altivec - implementation using Altivec (PowerPC only)
<div class="Pp"></div>
Default value: <b>fastest</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_vdev_scheduler</b> (charp)
<div class="Bd-indent"><b>DEPRECATED</b>: This option exists for compatibility
  with older user configurations. It does nothing except print a warning to the
  kernel log if set.
<div class="Pp"></div>
</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_zevent_len_max</b> (int)
<div class="Bd-indent">Max event queue length. Events in the queue can be viewed
  with the <b>zpool events</b> command.
<div class="Pp"></div>
Default value: <b>512</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_zevent_retain_max</b> (int)
<div class="Bd-indent">Maximum recent zevent records to retain for duplicate
  checking. Setting this value to zero disables duplicate detection.
<div class="Pp"></div>
Default value: <b>2000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_zevent_retain_expire_secs</b> (int)
<div class="Bd-indent">Lifespan for a recent ereport that was retained for
  duplicate checking.
<div class="Pp"></div>
Default value: <b>900</b>.</div>
<div class="Pp"></div>
<b>zfs_zil_clean_taskq_maxalloc</b> (int)
<div class="Bd-indent">The maximum number of taskq entries that are allowed to
  be cached. When this limit is exceeded transaction records (itxs) will be
  cleaned synchronously.
<div class="Pp"></div>
Default value: <b>1048576</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_zil_clean_taskq_minalloc</b> (int)
<div class="Bd-indent">The number of taskq entries that are pre-populated when
  the taskq is first created and are immediately available for use.
<div class="Pp"></div>
Default value: <b>1024</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_zil_clean_taskq_nthr_pct</b> (int)
<div class="Bd-indent">This controls the number of threads used by the
  dp_zil_clean_taskq. The default value of 100% will create a maximum of one
  thread per cpu.
<div class="Pp"></div>
Default value: <b>100</b>%.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zil_maxblocksize</b> (int)
<div class="Bd-indent">This sets the maximum block size used by the ZIL. On very
  fragmented pools, lowering this (typically to 36KB) can improve performance.
<div class="Pp"></div>
Default value: <b>131072</b> (128KB).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zil_nocacheflush</b> (int)
<div class="Bd-indent">Disable the cache flush commands that are normally sent
  to the disk(s) by the ZIL after an LWB write has completed. Setting this will
  cause ZIL corruption on power loss if a volatile out-of-order write cache is
  enabled.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zil_replay_disable</b> (int)
<div class="Bd-indent">Disable intent logging replay. Can be disabled for
  recovery from corrupted ZIL
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zil_slog_bulk</b> (ulong)
<div class="Bd-indent">Limit SLOG write size per commit executed with
  synchronous priority. Any writes above that will be executed with lower
  (asynchronous) priority to limit potential SLOG device abuse by single active
  ZIL writer.
<div class="Pp"></div>
Default value: <b>786,432</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zfs_embedded_slog_min_ms</b> (int)
<div class="Bd-indent">Usually, one metaslab from each (normal-class) vdev is
  dedicated for use by the ZIL (to log synchronous writes). However, if there
  are fewer than zfs_embedded_slog_min_ms metaslabs in the vdev, this
  functionality is disabled. This ensures that we don't set aside an
  unreasonable amount of space for the ZIL.
<div class="Pp"></div>
Default value: <b>64</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_deadman_log_all</b> (int)
<div class="Bd-indent">If non-zero, the zio deadman will produce debugging
  messages (see <b>zfs_dbgmsg_enable</b>) for all zios, rather than only for
  leaf zios possessing a vdev. This is meant to be used by developers to gain
  diagnostic information for hang conditions which don't involve a mutex or
  other locking primitive; typically conditions in which a thread in the zio
  pipeline is looping indefinitely.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_slow_io_ms</b> (int)
<div class="Bd-indent">When an I/O operation takes more than
  <b>zio_slow_io_ms</b> milliseconds to complete is marked as a slow I/O. Each
  slow I/O causes a delay zevent. Slow I/O counters can be seen with &quot;zpool
  status -s&quot;.
<div class="Pp"></div>
<div class="Pp"></div>
Default value: <b>30,000</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_dva_throttle_enabled</b> (int)
<div class="Bd-indent">Throttle block allocations in the I/O pipeline. This
  allows for dynamic allocation distribution when devices are imbalanced. When
  enabled, the maximum number of pending allocations per top-level vdev is
  limited by <b>zfs_vdev_queue_depth_pct</b>.
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_requeue_io_start_cut_in_line</b> (int)
<div class="Bd-indent">Prioritize requeued I/O
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_taskq_batch_pct</b> (uint)
<div class="Bd-indent">Percentage of online CPUs (or CPU cores, etc) which will
  run a worker thread for I/O. These workers are responsible for I/O work such
  as compression and checksum calculations. Fractional number of CPUs will be
  rounded down.
<div class="Pp"></div>
The default value of 80 was chosen to avoid using all CPUs which can result in
  latency issues and inconsistent application performance, especially when
  slower compression and/or checksumming is enabled.
<div class="Pp"></div>
Default value: <b>80</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zio_taskq_batch_tpq</b> (uint)
<div class="Bd-indent">Number of worker threads per taskq. Lower value improves
  I/O ordering and CPU utilization, while higher reduces lock contention.
<div class="Pp"></div>
By default about 6 worker threads per taskq, depending on system size.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_inhibit_dev</b> (uint)
<div class="Bd-indent">Do not create zvol device nodes. This may slightly
  improve startup time on systems with a very large number of zvols.
<div class="Pp"></div>
Use <b>1</b> for yes and <b>0</b> for no (default).</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_major</b> (uint)
<div class="Bd-indent">Major number for zvol block devices
<div class="Pp"></div>
Default value: <b>230</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_max_discard_blocks</b> (ulong)
<div class="Bd-indent">Discard (aka TRIM) operations done on zvols will be done
  in batches of this many blocks, where block size is determined by the
  <b>volblocksize</b> property of a zvol.
<div class="Pp"></div>
Default value: <b>16,384</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_prefetch_bytes</b> (uint)
<div class="Bd-indent">When adding a zvol to the system prefetch
  <b>zvol_prefetch_bytes</b> from the start and end of the volume. Prefetching
  these regions of the volume is desirable because they are likely to be
  accessed immediately by <b>blkid(8)</b> or by the kernel scanning for a
  partition table.
<div class="Pp"></div>
Default value: <b>131,072</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_request_sync</b> (uint)
<div class="Bd-indent">When processing I/O requests for a zvol submit them
  synchronously. This effectively limits the queue depth to 1 for each I/O
  submitter. When set to 0 requests are handled asynchronously by a thread pool.
  The number of requests which can be handled concurrently is controller by
  <b>zvol_threads</b>.
<div class="Pp"></div>
Default value: <b>0</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_threads</b> (uint)
<div class="Bd-indent">Max number of threads which can handle zvol I/O requests
  concurrently.
<div class="Pp"></div>
Default value: <b>32</b>.</div>
<div class="Pp"></div>
<div class="Pp"></div>
<b>zvol_volmode</b> (uint)
<div class="Bd-indent">Defines zvol block devices behaviour when <b>volmode</b>
  is set to <b>default</b>. Valid values are <b>1</b> (full), <b>2</b> (dev) and
  <b>3</b> (none).
<div class="Pp"></div>
Default value: <b>1</b>.</div>
<div class="Pp"></div>
<h1 class="Sh" title="Sh" id="ZFS_I/O_SCHEDULER"><a class="permalink" href="#ZFS_I/O_SCHEDULER">ZFS
  I/O SCHEDULER</a></h1>
ZFS issues I/O operations to leaf vdevs to satisfy and complete I/Os. The I/O
  scheduler determines when and in what order those operations are issued. The
  I/O scheduler divides operations into five I/O classes prioritized in the
  following order: sync read, sync write, async read, async write, and
  scrub/resilver. Each queue defines the minimum and maximum number of
  concurrent operations that may be issued to the device. In addition, the
  device has an aggregate maximum, <b>zfs_vdev_max_active</b>. Note that the sum
  of the per-queue minimums must not exceed the aggregate maximum. If the sum of
  the per-queue maximums exceeds the aggregate maximum, then the number of
  active I/Os may reach <b>zfs_vdev_max_active</b>, in which case no further
  I/Os will be issued regardless of whether all per-queue minimums have been
  met.
<div class="Pp"></div>
For many physical devices, throughput increases with the number of concurrent
  operations, but latency typically suffers. Further, physical devices typically
  have a limit at which more concurrent operations have no effect on throughput
  or can actually cause it to decrease.
<div class="Pp"></div>
The scheduler selects the next operation to issue by first looking for an I/O
  class whose minimum has not been satisfied. Once all are satisfied and the
  aggregate maximum has not been hit, the scheduler looks for classes whose
  maximum has not been satisfied. Iteration through the I/O classes is done in
  the order specified above. No further operations are issued if the aggregate
  maximum number of concurrent operations has been hit or if there are no
  operations queued for an I/O class that has not hit its maximum. Every time an
  I/O is queued or an operation completes, the I/O scheduler looks for new
  operations to issue.
<div class="Pp"></div>
In general, smaller max_active's will lead to lower latency of synchronous
  operations. Larger max_active's may lead to higher overall throughput,
  depending on underlying storage.
<div class="Pp"></div>
The ratio of the queues' max_actives determines the balance of performance
  between reads, writes, and scrubs. E.g., increasing
  <b>zfs_vdev_scrub_max_active</b> will cause the scrub or resilver to complete
  more quickly, but reads and writes to have higher latency and lower
  throughput.
<div class="Pp"></div>
All I/O classes have a fixed maximum number of outstanding operations except for
  the async write class. Asynchronous writes represent the data that is
  committed to stable storage during the syncing stage for transaction groups.
  Transaction groups enter the syncing state periodically so the number of
  queued async writes will quickly burst up and then bleed down to zero. Rather
  than servicing them as quickly as possible, the I/O scheduler changes the
  maximum number of active async write I/Os according to the amount of dirty
  data in the pool. Since both throughput and latency typically increase with
  the number of concurrent operations issued to physical devices, reducing the
  burstiness in the number of concurrent operations also stabilizes the response
  time of operations from other -- and in particular synchronous -- queues. In
  broad strokes, the I/O scheduler will issue more concurrent operations from
  the async write queue as there's more dirty data in the pool.
<div class="Pp"></div>
Async Writes
<div class="Pp"></div>
The number of concurrent operations issued for the async write I/O class follows
  a piece-wise linear function defined by a few adjustable points.
<pre>
<div class="Pp"></div>
       |              o---------| &lt;-- zfs_vdev_async_write_max_active
  ^    |             /^         |
  |    |            / |         |
active |           /  |         |
 I/O   |          /   |         |
count  |         /    |         |
       |        /     |         |
       |-------o      |         | &lt;-- zfs_vdev_async_write_min_active
      0|_______^______|_________|
       0%      |      |       100% of zfs_dirty_data_max
               |      |
               |      `-- zfs_vdev_async_write_active_max_dirty_percent
               `--------- zfs_vdev_async_write_active_min_dirty_percent
<div class="Pp"></div>
</pre>
Until the amount of dirty data exceeds a minimum percentage of the dirty data
  allowed in the pool, the I/O scheduler will limit the number of concurrent
  operations to the minimum. As that threshold is crossed, the number of
  concurrent operations issued increases linearly to the maximum at the
  specified maximum percentage of the dirty data allowed in the pool.
<div class="Pp"></div>
Ideally, the amount of dirty data on a busy pool will stay in the sloped part of
  the function between <b>zfs_vdev_async_write_active_min_dirty_percent</b> and
  <b>zfs_vdev_async_write_active_max_dirty_percent</b>. If it exceeds the
  maximum percentage, this indicates that the rate of incoming data is greater
  than the rate that the backend storage can handle. In this case, we must
  further throttle incoming writes, as described in the next section.
<div class="Pp"></div>
<h1 class="Sh" title="Sh" id="ZFS_TRANSACTION_DELAY"><a class="permalink" href="#ZFS_TRANSACTION_DELAY">ZFS
  TRANSACTION DELAY</a></h1>
We delay transactions when we've determined that the backend storage isn't able
  to accommodate the rate of incoming writes.
<div class="Pp"></div>
If there is already a transaction waiting, we delay relative to when that
  transaction will finish waiting. This way the calculated delay time is
  independent of the number of threads concurrently executing transactions.
<div class="Pp"></div>
If we are the only waiter, wait relative to when the transaction started, rather
  than the current time. This credits the transaction for &quot;time already
  served&quot;, e.g. reading indirect blocks.
<div class="Pp"></div>
The minimum time for a transaction to take is calculated as:
<pre>
    min_time = zfs_delay_scale * (dirty - min) / (max - dirty)
    min_time is then capped at 100 milliseconds.
</pre>
<div class="Pp"></div>
The delay has two degrees of freedom that can be adjusted via tunables. The
  percentage of dirty data at which we start to delay is defined by
  <b>zfs_delay_min_dirty_percent</b>. This should typically be at or above
  <b>zfs_vdev_async_write_active_max_dirty_percent</b> so that we only start to
  delay after writing at full speed has failed to keep up with the incoming
  write rate. The scale of the curve is defined by <b>zfs_delay_scale</b>.
  Roughly speaking, this variable determines the amount of delay at the midpoint
  of the curve.
<div class="Pp"></div>
<pre>
delay
 10ms +-------------------------------------------------------------*+
      |                                                             *|
  9ms +                                                             *+
      |                                                             *|
  8ms +                                                             *+
      |                                                            * |
  7ms +                                                            * +
      |                                                            * |
  6ms +                                                            * +
      |                                                            * |
  5ms +                                                           *  +
      |                                                           *  |
  4ms +                                                           *  +
      |                                                           *  |
  3ms +                                                          *   +
      |                                                          *   |
  2ms +                                              (midpoint) *    +
      |                                                  |    **     |
  1ms +                                                  v ***       +
      |             zfs_delay_scale ----------&gt;     ********         |
    0 +-------------------------------------*********----------------+
      0%                    &lt;- zfs_dirty_data_max -&gt;               100%
</pre>
<div class="Pp"></div>
Note that since the delay is added to the outstanding time remaining on the most
  recent transaction, the delay is effectively the inverse of IOPS. Here the
  midpoint of 500us translates to 2000 IOPS. The shape of the curve was chosen
  such that small changes in the amount of accumulated dirty data in the first
  3/4 of the curve yield relatively small differences in the amount of delay.
<div class="Pp"></div>
The effects can be easier to understand when the amount of delay is represented
  on a log scale:
<div class="Pp"></div>
<pre>
delay
100ms +-------------------------------------------------------------++
      +                                                              +
      |                                                              |
      +                                                             *+
 10ms +                                                             *+
      +                                                           ** +
      |                                              (midpoint)  **  |
      +                                                  |     **    +
  1ms +                                                  v ****      +
      +             zfs_delay_scale ----------&gt;        *****         +
      |                                             ****             |
      +                                          ****                +
100us +                                        **                    +
      +                                       *                      +
      |                                      *                       |
      +                                     *                        +
 10us +                                     *                        +
      +                                                              +
      |                                                              |
      +                                                              +
      +--------------------------------------------------------------+
      0%                    &lt;- zfs_dirty_data_max -&gt;               100%
</pre>
<div class="Pp"></div>
Note here that only as the amount of dirty data approaches its limit does the
  delay start to increase rapidly. The goal of a properly tuned system should be
  to keep the amount of dirty data out of that range by first ensuring that the
  appropriate limits are set for the I/O scheduler to reach optimal throughput
  on the backend storage, and then by changing the value of
  <b>zfs_delay_scale</b> to increase the steepness of the curve.</div>
<table class="foot">
  <tr>
    <td class="foot-date">May 5, 2021</td>
    <td class="foot-os">OpenZFS</td>
  </tr>
</table>
</div></div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="zpool-features.5.html" class="btn btn-neutral float-right" title="zpool-features.5" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="zfs-events.5.html" class="btn btn-neutral float-left" title="zfs-events.5" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, OpenZFS.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>